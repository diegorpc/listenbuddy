import { Collection, Db } from "npm:mongodb";
import { ID } from "@utils/types.ts";
import { freshID } from "@utils/database.ts";

// Declare collection prefix, use concept name
const PREFIX = "MusicBrainzAPI" + ".";

// MusicBrainz API Configuration
const MUSICBRAINZ_API_BASE_URL = "https://musicbrainz.org/ws/2/";
const COVER_ART_API_BASE_URL = "https://coverartarchive.org/release/";
const RATE_LIMIT_DELAY_MS = 1100; // ~1 request per second + buffer
const USER_AGENT = "ListenBuddy/1.0.0 (diegorpc@mit.edu)";

// Generic types of this concept
type EntityMbid = ID;
type EntityType =
  | "artist"
  | "recording"
  | "release"
  | "release-group"
  | "work";

// Detailed MusicBrainz API response types based on actual responses
interface MBLifeSpan {
  begin?: string | null;
  end?: string | null;
  ended: boolean;
}

interface MBArea {
  id: string;
  type?: string | null;
  "type-id"?: string | null;
  name: string;
  "sort-name": string;
  disambiguation?: string;
  "iso-3166-1-codes"?: string[];
  "life-span"?: MBLifeSpan;
}

interface MBArtist {
  id: string;
  name: string;
  "sort-name": string;
  disambiguation?: string;
  type?: string;
  "type-id"?: string;
  "gender"?: string | null;
  "gender-id"?: string | null;
  country?: string;
  area?: MBArea;
  "begin-area"?: MBArea;
  "end-area"?: MBArea | null;
  "life-span"?: MBLifeSpan;
  ipis?: string[];
  isnis?: string[];
  aliases?: MBAlias[];
  tags?: MBTag[];
  relations?: MBRelation[];
  releases?: MBRelease[];
}

interface MBAlias {
  name: string;
  "sort-name": string;
  type?: string;
  "type-id"?: string;
  locale?: string | null;
  primary?: boolean | null;
  "begin-date"?: string | null;
  "end-date"?: string | null;
}

interface MBTag {
  name: string;
  count: number;
}

interface MBArtistCredit {
  name: string;
  artist?: MBArtist;
  joinphrase?: string;
}

interface MBWork {
  id: string;
  title: string;
  type?: string;
  "type-id"?: string;
  disambiguation?: string;
  language?: string;
  languages?: string[];
  iswcs?: string[];
  attributes?: MBWorkAttribute[];
  relations?: MBRelation[];
}

interface MBWorkAttribute {
  type: string;
  "type-id": string;
  value: string;
}

interface MBRecording {
  id: string;
  title: string;
  length?: number;
  disambiguation?: string;
  video?: boolean;
  "artist-credit"?: MBArtistCredit[];
  releases?: MBRelease[];
  isrcs?: string[];
  tags?: MBTag[];
  relations?: MBRelation[];
}

interface MBRelease {
  id: string;
  title: string;
  status?: string;
  "status-id"?: string;
  date?: string;
  country?: string;
  disambiguation?: string;
  barcode?: string | null;
  "artist-credit"?: MBArtistCredit[];
  "release-group"?: MBReleaseGroup;
  media?: MBMedia[];
  "label-info"?: MBLabelInfo[];
  "cover-art-archive"?: MBCoverArtArchive;
  relations?: MBRelation[];
}

interface MBMedia {
  title?: string;
  position: number;
  format?: string;
  "format-id"?: string;
  "track-count": number;
  "track-offset"?: number;
  tracks?: MBTrack[];
}

interface MBTrack {
  id: string;
  position: number;
  number: string;
  title: string;
  length?: number;
  recording?: MBRecording;
  "artist-credit"?: MBArtistCredit[];
}

interface MBReleaseGroup {
  id: string;
  title: string;
  "primary-type"?: string;
  "primary-type-id"?: string;
  "secondary-types"?: string[];
  "secondary-type-ids"?: string[];
  "first-release-date"?: string;
  disambiguation?: string;
  "artist-credit"?: MBArtistCredit[];
  releases?: MBRelease[];
  tags?: MBTag[];
  relations?: MBRelation[];
}

interface MBLabelInfo {
  "catalog-number"?: string;
  label?: MBLabel;
}

interface MBLabel {
  id: string;
  name: string;
  "sort-name": string;
  disambiguation?: string;
  type?: string;
  "type-id"?: string;
}

interface MBCoverArtArchive {
  artwork: boolean;
  count: number;
  front: boolean;
  back: boolean;
  darkened: boolean;
}

interface MBRelation {
  type: string;
  "type-id"?: string;
  "target-type": string;
  "target-credit"?: string;
  "source-credit"?: string;
  direction?: string;
  begin?: string;
  end?: string;
  ended?: boolean;
  attributes?: string[];
  "attribute-values"?: Record<string, string>;
  "attribute-ids"?: Record<string, string>;
  artist?: MBArtist;
  work?: MBWork;
  recording?: MBRecording;
  release?: MBRelease;
  "release-group"?: MBReleaseGroup;
  url?: MBUrl;
  genre?: MBGenre;
}

interface MBUrl {
  id: string;
  resource: string;
}

interface MBGenre {
  id: string;
  name: string;
  disambiguation?: string;
}

interface MBSearchResult {
  score: number;
  id: string;
  name?: string;
  title?: string;
  "sort-name"?: string;
  type?: string;
  "type-id"?: string;
  disambiguation?: string;
  country?: string;
  area?: MBArea;
  "begin-area"?: MBArea;
  "life-span"?: MBLifeSpan;
  isnis?: string[];
  aliases?: MBAlias[];
  tags?: MBTag[];
  "artist-credit"?: MBArtistCredit[];
}

/**
 * A set of EntityCache with:
 *   an _id of type ID (unique identifier generated by freshID)
 *   a cacheKey of type String (full URL used for lookups)
 *   an mbid of type String (MusicBrainz ID)
 *   an entityType of type String ("artist", "recording", "release", "release-group", "work")
 *   a metadata of type JSON
 *   a lastFetched of type Timestamp
 */
interface EntityCache {
  _id: ID; // Unique ID generated by freshID()
  cacheKey: string; // Full URL including query params
  mbid: EntityMbid | string | null; // Can be null for search/browse
  entityType: EntityType | "search" | "browse";
  metadata: unknown; // JSON data from API responses
  relationships?: unknown; // For search/browse results
  lastFetched: Date;
}

// In-memory rate limit state for simplicity, can be made persistent if needed for distributed instances
interface RateLimitState {
  lastRequestTime: Date;
}

export default class MusicBrainzAPIConcept {
  private entityCache: Collection<EntityCache>;
  private rateLimitState: RateLimitState;

  // TTL for cache (can be adjusted)
  private static readonly ENTITY_CACHE_TTL_MS = 24 * 60 * 60 * 1000; // 24 hours

  constructor(private readonly db: Db) {
    this.entityCache = this.db.collection(PREFIX + "entityCache");
    this.rateLimitState = { lastRequestTime: new Date(0) }; // Initialize to a past date
  }

  /**
   * Internal helper to enforce MusicBrainz API rate limit (1 request/second).
   * Blocks until enough time has passed since the last request.
   */
  private async _waitForRateLimit(): Promise<void> {
    const now = new Date();
    const timeSinceLastRequest = now.getTime() -
      this.rateLimitState.lastRequestTime.getTime();

    if (timeSinceLastRequest < RATE_LIMIT_DELAY_MS) {
      const delay = RATE_LIMIT_DELAY_MS - timeSinceLastRequest;
      // console.warn(`MusicBrainzAPI: Rate limit hit. Waiting for ${delay}ms.`);
      await new Promise((resolve) => setTimeout(resolve, delay));
    }
    this.rateLimitState.lastRequestTime = new Date(); // Update last request time
  }

  /**
   * Internal helper to make a request to the MusicBrainz API, handling caching and rate limiting.
   * @param entityType The type of entity or request being made.
   * @param mbid The MusicBrainz ID (can be null for search/browse).
   * @param requestUrl The complete URL for the API request.
   * @param cacheCollection The MongoDB collection to use for caching.
   * @param ttlMs Time-to-live for the cache entry in milliseconds.
   * @returns The parsed JSON response or an error object.
   */
  private async _fetchAndCache<T>(
    entityType: EntityType | "search" | "browse",
    mbid: EntityMbid | string | null, // Can be null for search/browse
    requestUrl: URL,
    cacheCollection: Collection<any>,
    ttlMs: number,
  ): Promise<T | { error: string }> {
    // Use full URL as cache key to include query parameters (like inc=releases)
    // This ensures different includes don't share the same cache entry
    const cacheKey = requestUrl.toString();

    // 1. Check cache first
    const cachedData = await cacheCollection.findOne({ cacheKey });

    if (cachedData) {
      if (
        new Date().getTime() - cachedData.lastFetched.getTime() <
          ttlMs
      ) {
        // console.log(`MusicBrainzAPI: Cache hit for ${cacheKey}`);
        return cachedData.metadata || cachedData.relationships;
      } else {
        // console.log(`MusicBrainzAPI: Cache expired for ${cacheKey}`);
        // Optionally delete expired cache here to keep it clean, but usually just overwrite.
      }
    }

    // 2. Enforce rate limit and Make the API call with retries
    const maxAttempts = 3;
    let lastError: unknown = undefined;
    let data: any = null;
    for (let attempt = 1; attempt <= maxAttempts; attempt++) {
      try {
        await this._waitForRateLimit();
        const response = await fetch(requestUrl.toString(), {
          headers: {
            "User-Agent": USER_AGENT,
            "Accept": "application/json",
          },
        });

        if (!response.ok) {
          await response.body?.cancel();
          if (response.status === 404 || response.status === 400) {
            return { error: `Entity not found: ${mbid}` };
          }
          // Retry on transient server errors
          if ([429, 500, 502, 503, 504].includes(response.status)) {
            lastError = new Error(
              `MusicBrainz API error: ${response.status} ${response.statusText}`,
            );
          } else {
            throw new Error(
              `MusicBrainz API error: ${response.status} ${response.statusText}`,
            );
          }
        } else {
          data = await response.json();
          lastError = undefined;
          break;
        }
      } catch (error: unknown) {
        // Network or fetch error, capture and retry
        lastError = error;
      }

      // If we will retry, wait with exponential backoff + small jitter
      if (attempt < maxAttempts) {
        const backoffMs = Math.min(4000, 500 * Math.pow(2, attempt - 1));
        const jitter = Math.floor(Math.random() * 150);
        await new Promise((resolve) => setTimeout(resolve, backoffMs + jitter));
      }
    }

    if (lastError) {
      const errorMessage = lastError instanceof Error
        ? lastError.message
        : String(lastError);
      console.error(
        `MusicBrainzAPI: Error fetching ${requestUrl.toString()}:`,
        lastError,
      );
      return {
        error: `Failed to fetch from MusicBrainz API: ${errorMessage}`,
      };
    }

    // 4. Cache the result
    const cacheUpdate: Partial<EntityCache> & {
      cacheKey: string;
      lastFetched: Date;
    } = {
      cacheKey,
      lastFetched: new Date(),
    };

    if (
      entityType === "artist" ||
      entityType === "recording" ||
      entityType === "release" ||
      entityType === "release-group" ||
      entityType === "work"
    ) {
      Object.assign(cacheUpdate, {
        mbid: mbid,
        entityType: entityType,
        metadata: data,
      });
    } else { // This handles search and browse
      Object.assign(cacheUpdate, {
        mbid: mbid, // Can be null for search/browse but still useful
        entityType: entityType, // Store the type for reference
        metadata: data, // Store full response for search/browse
        relationships: data.relations || data.artists || data.recordings ||
          data.releases || data["release-groups"] || data.works, // Extract specific lists if available
      });
    }

    await cacheCollection.updateOne(
      { cacheKey },
      {
        $set: cacheUpdate,
        $setOnInsert: { _id: freshID() }, // Generate ID only on first insert
      },
      { upsert: true },
    );
    // console.log(`MusicBrainzAPI: Cached ${cacheKey}`);

    // Return the actual data part for different request types
    if (entityType === "search" || entityType === "browse") {
      return cacheUpdate.metadata as T;
    }
    return (cacheUpdate.metadata || cacheUpdate.relationships) as T;
  }

  /**
   * lookupArtist(mbid: String, includes: List<String>): (artist: JSON)
   *
   * requires: mbid is valid MusicBrainz artist ID, includes contains valid subquery types
   * effect: fetches detailed artist information from MusicBrainz API including optional subqueries (recordings, releases, release-groups, works, artist-rels, etc.).
   * Returns artist name, aliases, area, type, and requested linked entities.
   */
  async lookupArtist(
    { mbid, includes = [] }: { mbid: EntityMbid; includes?: string[] },
  ): Promise<{ artist?: MBArtist; error?: string }> {
    if (!mbid) return { error: "MBID is required." };

    const url = new URL(`${MUSICBRAINZ_API_BASE_URL}artist/${mbid}`);
    url.searchParams.set("fmt", "json");
    if (includes.length > 0) {
      url.searchParams.set("inc", includes.join("+"));
    }

    const result = await this._fetchAndCache<any>(
      "artist",
      mbid,
      url,
      this.entityCache,
      MusicBrainzAPIConcept.ENTITY_CACHE_TTL_MS,
    );
    if ("error" in result) return result;
    // MusicBrainz API returns entity data directly at the root
    return { artist: result };
  }

  /**
   * lookupRecording(mbid: String, includes: List<String>): (recording: JSON)
   *
   * requires: mbid is valid MusicBrainz recording ID, includes contains valid subquery types
   * effect: fetches recording (track/song) information including title, length, artists, and optionally releases, ISRCs, work relationships, and artist relationships.
   */
  async lookupRecording(
    { mbid, includes = [] }: { mbid: EntityMbid; includes?: string[] },
  ): Promise<{ recording?: MBRecording; error?: string }> {
    if (!mbid) return { error: "MBID is required." };

    const url = new URL(`${MUSICBRAINZ_API_BASE_URL}recording/${mbid}`);
    url.searchParams.set("fmt", "json");
    if (includes.length > 0) {
      url.searchParams.set("inc", includes.join("+"));
    }

    const result = await this._fetchAndCache<any>(
      "recording",
      mbid,
      url,
      this.entityCache,
      MusicBrainzAPIConcept.ENTITY_CACHE_TTL_MS,
    );
    if ("error" in result) return result;
    // MusicBrainz API returns entity data directly at the root
    return { recording: result };
  }

  /**
   * lookupRelease(mbid: String, includes: List<String>): (release: JSON)
   *
   * requires: mbid is valid MusicBrainz release ID, includes contains valid subquery types
   * effect: fetches release (album) information including title, date, status, artists, labels, and optionally recordings, release-group, cover art, and relationships.
   */
  async lookupRelease(
    { mbid, includes = [] }: { mbid: EntityMbid; includes?: string[] },
  ): Promise<{ release?: MBRelease; error?: string }> {
    if (!mbid) return { error: "MBID is required." };

    const url = new URL(`${MUSICBRAINZ_API_BASE_URL}release/${mbid}`);
    url.searchParams.set("fmt", "json");
    if (includes.length > 0) {
      url.searchParams.set("inc", includes.join("+"));
    }

    const result = await this._fetchAndCache<any>(
      "release",
      mbid,
      url,
      this.entityCache,
      MusicBrainzAPIConcept.ENTITY_CACHE_TTL_MS,
    );
    if ("error" in result) return result;
    // MusicBrainz API returns entity data directly at the root
    return { release: result };
  }

  /**
   * lookupReleaseGroup(mbid: String, includes: List<String>): (releaseGroup: JSON)
   *
   * requires: mbid is valid MusicBrainz release-group ID, includes contains valid subquery types
   * effect: fetches release group information including title, type, artists, and optionally individual releases and relationships.
   */
  async lookupReleaseGroup(
    { mbid, includes = [] }: { mbid: EntityMbid; includes?: string[] },
  ): Promise<{ releaseGroup?: MBReleaseGroup; error?: string }> {
    if (!mbid) return { error: "MBID is required." };

    const url = new URL(`${MUSICBRAINZ_API_BASE_URL}release-group/${mbid}`);
    url.searchParams.set("fmt", "json");
    if (includes.length > 0) {
      url.searchParams.set("inc", includes.join("+"));
    }

    const result = await this._fetchAndCache<any>(
      "release-group",
      mbid,
      url,
      this.entityCache,
      MusicBrainzAPIConcept.ENTITY_CACHE_TTL_MS,
    );
    if ("error" in result) return result;
    // MusicBrainz API returns entity data directly at the root
    return { releaseGroup: result };
  }

  /**
   * lookupWork(mbid: String, includes: List<String>): (work: JSON)
   *
   * requires: mbid is valid MusicBrainz work ID, includes contains valid subquery types
   * effect: fetches work (composition) information including title, type, and relationships to artists (composers, lyricists), recordings, and other works.
   */
  async lookupWork(
    { mbid, includes = [] }: { mbid: EntityMbid; includes?: string[] },
  ): Promise<{ work?: MBWork; error?: string }> {
    if (!mbid) return { error: "MBID is required." };

    const url = new URL(`${MUSICBRAINZ_API_BASE_URL}work/${mbid}`);
    url.searchParams.set("fmt", "json");
    if (includes.length > 0) {
      url.searchParams.set("inc", includes.join("+"));
    }

    const result = await this._fetchAndCache<any>(
      "work",
      mbid,
      url,
      this.entityCache,
      MusicBrainzAPIConcept.ENTITY_CACHE_TTL_MS,
    );
    if ("error" in result) return result;
    // MusicBrainz API returns entity data directly at the root
    return { work: result };
  }

  /**
   * searchEntities(query: String, entityType: String, limit: Number): (results: List<JSON>)
   *
   * requires: query is non-empty, entityType is valid ("artist", "recording", "release", etc.), limit is positive
   * effect: searches MusicBrainz database for entities matching the query string. Returns ranked list of matching entities with scores.
   */
  async searchEntities(
    { query, entityType, limit = 25 }: {
      query: string;
      entityType: EntityType;
      limit?: number;
    },
  ): Promise<{ results?: MBSearchResult[]; error?: string }> {
    if (!query || query.trim() === "") {
      return { error: "Query cannot be empty." };
    }
    if (
      !["artist", "recording", "release", "release-group", "work"].includes(
        entityType,
      )
    ) {
      return { error: "Invalid entityType." };
    }
    if (limit <= 0) return { error: "Limit must be positive." };

    const url = new URL(`${MUSICBRAINZ_API_BASE_URL}${entityType}`);
    url.searchParams.set("fmt", "json");
    url.searchParams.set("query", query);
    url.searchParams.set("limit", limit.toString());

    const result = await this._fetchAndCache<any>(
      "search",
      null, // No specific MBID for search
      url,
      this.entityCache, // Using entityCache for search results as well
      MusicBrainzAPIConcept.ENTITY_CACHE_TTL_MS,
    );
    if ("error" in result) return result;

    // MusicBrainz search results are typically under an array key matching the entity type (e.g., 'artists', 'recordings')
    // Handle special case for release-group which becomes release-groups in the API response
    const entityKey = entityType === "release-group"
      ? "release-groups"
      : `${entityType}s`;
    return { results: result[entityKey] || [] };
  }

  /**
   * browseByEntity(entityType: String, linkedEntity: String, linkedMbid: String, limit: Number, offset: Number): (results: List<JSON>)
   *
   * requires: entityType and linkedEntity are valid types, linkedMbid exists, limit and offset are non-negative
   * effect: browses entities linked to a specific entity (e.g., all releases by an artist, all recordings of a work). Supports pagination.
   */
  async browseByEntity(
    { entityType, linkedEntity, linkedMbid, limit = 25, offset = 0 }: {
      entityType: EntityType;
      linkedEntity: EntityType;
      linkedMbid: EntityMbid;
      limit?: number;
      offset?: number;
    },
  ): Promise<
    {
      results?:
        (MBArtist | MBRecording | MBRelease | MBReleaseGroup | MBWork)[];
      error?: string;
    }
  > {
    if (!linkedMbid) return { error: "linkedMbid is required." };
    if (
      !["artist", "recording", "release", "release-group", "work"].includes(
        entityType,
      )
    ) {
      return { error: "Invalid entityType." };
    }
    if (
      !["artist", "recording", "release", "release-group", "work"].includes(
        linkedEntity,
      )
    ) {
      return { error: "Invalid linkedEntity type." };
    }
    if (limit < 0 || offset < 0) {
      return { error: "Limit and offset must be non-negative." };
    }

    const url = new URL(`${MUSICBRAINZ_API_BASE_URL}${entityType}`);
    url.searchParams.set("fmt", "json");
    url.searchParams.set(linkedEntity, linkedMbid); // e.g., ?artist={mbid}
    url.searchParams.set("limit", limit.toString());
    url.searchParams.set("offset", offset.toString());

    const result = await this._fetchAndCache<any>(
      "browse",
      linkedMbid, // Use linkedMbid as a context for caching
      url,
      this.entityCache,
      MusicBrainzAPIConcept.ENTITY_CACHE_TTL_MS,
    );
    if ("error" in result) return result;

    // Handle special case for release-group which becomes release-groups in the API response
    const entityKey = entityType === "release-group"
      ? "release-groups"
      : `${entityType}s`;
    return { results: result[entityKey] || [] };
  }

  /**
   * getEntityGenres(mbid: String, entityType: String): (genres: List<Genre>)
   *
   * requires: mbid is valid, entityType is supported
   * effect: fetches genres (and tags) for an entity and returns them sorted by count/relevance.
   * Useful for finding similar entities based on genre overlap.
   */
  async getEntityGenres(
    { mbid, entityType }: { mbid: EntityMbid; entityType: EntityType },
  ): Promise<{ genres?: MBTag[]; tags?: MBTag[]; error?: string }> {
    if (!mbid) return { error: "MBID is required." };
    if (
      !["artist", "recording", "release", "release-group"].includes(
        entityType,
      )
    ) {
      return { error: "Invalid entityType for genre lookup." };
    }

    const url = new URL(`${MUSICBRAINZ_API_BASE_URL}${entityType}/${mbid}`);
    url.searchParams.set("fmt", "json");
    url.searchParams.set("inc", "genres+tags");

    const result = await this._fetchAndCache<any>(
      entityType,
      mbid,
      url,
      this.entityCache,
      MusicBrainzAPIConcept.ENTITY_CACHE_TTL_MS,
    );

    if ("error" in result) return result;

    // Extract and sort genres and tags by count (descending)
    const genres = (result.genres || []).sort(
      (a: MBTag, b: MBTag) => b.count - a.count,
    );
    const tags = (result.tags || []).sort(
      (a: MBTag, b: MBTag) => b.count - a.count,
    );

    return { genres, tags };
  }

  /**
   * getArtistSimilarities(artistMbid: String, limit: Number): (similarArtists: List<Artist>)
   *
   * requires: artistMbid is valid
   * effect: finds similar artists based on genre/tag overlap. Fetches the artist's top genres,
   * searches for other artists with those genres, and returns a scored list of similar artists.
   * This is more useful for recommendations than relationship-based approaches.
   */
  async getArtistSimilarities(
    { artistMbid, limit = 10 }: { artistMbid: EntityMbid; limit?: number },
  ): Promise<
    {
      similarArtists?: Array<{
        mbid: string;
        name: string;
        score: number;
        sharedGenres: string[];
      }>;
      error?: string;
    }
  > {
    if (!artistMbid) return { error: "artistMbid is required." };

    // Step 1: Get the source artist's genres/tags
    const artistResult = await this.lookupArtist({
      mbid: artistMbid,
      includes: ["tags", "genres"],
    });
    if ("error" in artistResult || !artistResult.artist) {
      return { error: "Could not fetch artist details." };
    }
    const sourceArtist = artistResult.artist;
    const genres = (sourceArtist.tags || []).sort(
      (a: MBTag, b: MBTag) => b.count - a.count,
    );
    console.log("genres for ", artistMbid, ": ", genres);
    if (genres.length === 0) {
      return {
        similarArtists: [],
        error: "No genres/tags found for this artist.",
      };
    }

    // Step 2: Search by top tags and aggregate candidates without extra fetches
    const topGenres = genres.slice(0, 5);
    const artistCandidates = new Map<
      string,
      { name: string; sharedTags: Set<string>; score: number }
    >();
    const maxTotalArtistCandidates = limit * 4;
    for (const genre of topGenres.slice(0, 3)) {
      if (artistCandidates.size >= maxTotalArtistCandidates) break;
      let processedForGenre = 0;
      const maxPerGenre = Math.max(10, limit);
      const searchResult = await this.searchEntities({
        query: `tag:"${genre.name}"`,
        entityType: "artist",
        limit: 20,
      });
      if ("error" in searchResult || !searchResult.results) continue;

      for (const a of searchResult.results) {
        if (a.id === artistMbid) continue;
        const name = a.name || "Unknown";
        const searchScore = typeof a.score === "number"
          ? a.score
          : parseInt(String(a.score)) || 0;

        if (artistCandidates.has(a.id)) {
          const c = artistCandidates.get(a.id)!;
          c.sharedTags.add(genre.name);
          c.score += Math.sqrt(genre.count) * 2;
        } else {
          artistCandidates.set(a.id, {
            name,
            sharedTags: new Set<string>([genre.name]),
            score: Math.sqrt(genre.count) * 2 + (searchScore / 10),
          });
          processedForGenre++;
          if (
            processedForGenre >= maxPerGenre ||
            artistCandidates.size >= maxTotalArtistCandidates
          ) break;
        }
      }
      console.log(
        `Processed tag "${genre.name}" for artist ${artistMbid}; candidates: ${artistCandidates.size}`,
      );
    }

    const similarArtists = Array.from(artistCandidates.entries())
      .map(([mbid, data]) => ({
        mbid,
        name: data.name,
        score: Math.round(data.score * 100) / 100,
        sharedGenres: Array.from(data.sharedTags),
      }))
      .sort((a, b) => b.score - a.score)
      .slice(0, limit);

    return { similarArtists };
  }

  /**
   * getRecordingWorks(recordingMbid: String): (works: List<Work>)
   *
   * requires: recordingMbid is valid
   * effect: fetches the musical works (compositions) associated with a recording,
   * including composer and lyricist information.
   */
  async getRecordingWorks(
    { recordingMbid }: { recordingMbid: EntityMbid },
  ): Promise<{
    works?: Array<{
      mbid: string;
      title: string;
      type?: string;
      artists: Array<{ mbid: string; name: string; type: string }>;
    }>;
    error?: string;
  }> {
    if (!recordingMbid) return { error: "recordingMbid is required." };

    const recordingResult = await this.lookupRecording({
      mbid: recordingMbid,
      includes: ["work-rels"],
    });

    if ("error" in recordingResult) return recordingResult;

    const recording = recordingResult.recording;
    if (!recording) return { error: "Recording data not found." };
    const associatedWorks: Array<{
      mbid: string;
      title: string;
      type?: string;
      artists: Array<{ mbid: string; name: string; type: string }>;
    }> = [];

    if (recording.relations) {
      for (const rel of recording.relations) {
        if (
          rel.type === "performance" && rel["target-type"] === "work" &&
          rel.work
        ) {
          // Fetch full work details with artist relationships
          const workResult = await this.lookupWork({
            mbid: rel.work.id as ID,
            includes: ["artist-rels"],
          });

          if ("error" in workResult) continue; // Skip works that fail to fetch

          const workData = workResult.work;
          if (!workData) continue;
          const artists: Array<{ mbid: string; name: string; type: string }> =
            [];

          // Extract composer and lyricist relationships from work
          if (workData.relations) {
            for (const wrel of workData.relations) {
              if (
                wrel["target-type"] === "artist" &&
                ["composer", "lyricist"].includes(wrel.type) &&
                wrel.artist
              ) {
                artists.push({
                  mbid: wrel.artist.id,
                  name: wrel.artist.name,
                  type: wrel.type,
                });
              }
            }
          }

          const work = {
            mbid: workData.id,
            title: workData.title,
            type: workData.type,
            artists: artists,
          };
          associatedWorks.push(work);
        }
      }
    }

    return { works: associatedWorks };
  }

  /**
   * getSimilarRecordings(recordingMbid: String, limit: Number): (similarRecordings: List<Recording>)
   *
   * requires: recordingMbid is valid
   * effect: finds similar recordings based on genre/tag overlap from their albums and artist similarity. Returns a scored list of similar recordings.
   * Note: Since recordings typically lack genre data, this method fetches the recording's releases and uses the first release's genres/tags.
   */
  async getSimilarRecordings(
    { recordingMbid, limit = 10 }: {
      recordingMbid: EntityMbid;
      limit?: number;
    },
  ): Promise<
    {
      similarRecordings?: Array<{
        mbid: string;
        title: string;
        artist?: string;
        score: number;
        sharedGenres: string[];
      }>;
      error?: string;
    }
  > {
    if (!recordingMbid) return { error: "recordingMbid is required." };

    // Step 1: Get the source recording with releases to fetch album genres
    // Recordings typically don't have genre data, so we get it from the album
    const recordingResult = await this.lookupRecording({
      mbid: recordingMbid,
      includes: ["releases", "artist-credits"],
    });

    if ("error" in recordingResult || !recordingResult.recording) {
      return { error: "Could not fetch recording details." };
    }

    const sourceRecording = recordingResult.recording;

    // Get artist info for additional context
    const artistCredit = sourceRecording["artist-credit"]?.[0];
    const artistName = artistCredit?.name || artistCredit?.artist?.name;
    const artistId = artistCredit?.artist?.id;

    // Step 2: Fetch genres from the first available release (album) instead of the recording
    let tags: MBTag[] = [];
    if (sourceRecording.releases && sourceRecording.releases.length > 0) {
      // Get the first release's genres - prefer official releases
      const officialRelease = sourceRecording.releases.find((r) =>
        r.status === "Official"
      ) || sourceRecording.releases[0];

      const releaseGenresResult = await this.getEntityGenres({
        mbid: officialRelease.id as ID,
        entityType: "release",
      });

      if (!("error" in releaseGenresResult)) {
        // Combine genres and tags, prioritizing genres
        tags = [
          ...(releaseGenresResult.genres || []),
          ...(releaseGenresResult.tags || []),
        ].sort((a: MBTag, b: MBTag) => b.count - a.count);
      }
    }

    console.log("tags for recording ", recordingMbid, " (from album): ", tags);

    // If album doesn't have tags, fall back to artist genres
    if (tags.length === 0 && artistId) {
      const artistGenresResult = await this.getEntityGenres({
        mbid: artistId as ID,
        entityType: "artist",
      });

      if (!("error" in artistGenresResult)) {
        tags = [
          ...(artistGenresResult.genres || []),
          ...(artistGenresResult.tags || []),
        ].sort((a: MBTag, b: MBTag) => b.count - a.count);
        console.log(
          "tags for recording ",
          recordingMbid,
          " (from artist fallback): ",
          tags,
        );
      }
    }

    if (tags.length === 0 && !artistId) {
      return {
        similarRecordings: [],
        error: "No genres/tags or artist found for this recording.",
      };
    }

    const recordingCandidates = new Map<
      string,
      {
        title: string;
        artist?: string;
        tags: MBTag[];
        sharedTags: Set<string>;
        score: number;
      }
    >();

    // Strategy 1: Search by tags if available
    if (tags.length > 0) {
      const topTags = tags.slice(0, 5);

      for (const tag of topTags) {
        // Use proper Lucene syntax for tag search
        const searchResult = await this.searchEntities({
          query: `tag:"${tag.name}"`,
          entityType: "recording",
          limit: 20,
        });

        if ("error" in searchResult || !searchResult.results) continue;

        let processedForTag = 0;
        const maxPerTag = Math.max(10, limit);
        const maxTotalRecordingCandidates = limit * 3;
        for (const recResult of searchResult.results) {
          if (recResult.id === recordingMbid) continue;

          // Compute lightweight fields from search result to avoid extra API calls
          const candidateArtistCredit = recResult["artist-credit"]?.[0] as
            | { name?: string; artist?: { name?: string } }
            | undefined;
          const candidateArtistName = candidateArtistCredit?.name ||
            candidateArtistCredit?.artist?.name;

          // Skip if already processed: just accumulate tag and boost score
          if (recordingCandidates.has(recResult.id)) {
            const candidate = recordingCandidates.get(recResult.id)!;
            candidate.sharedTags.add(tag.name);
            candidate.score += Math.sqrt(tag.count) * 2;
            continue;
          }

          // Initial scoring without fetching candidate details
          const sharedTags = new Set<string>([tag.name]);
          let score = Math.sqrt(tag.count) * 2;
          const searchScore = typeof recResult.score === "number"
            ? recResult.score
            : parseInt(String(recResult.score)) || 0;
          score += searchScore / 10;

          // Bonus for same artist
          if (
            artistName && candidateArtistName &&
            artistName.toLowerCase() === candidateArtistName.toLowerCase()
          ) {
            score += 50;
          }

          recordingCandidates.set(recResult.id, {
            title: recResult.title || "Unknown",
            artist: candidateArtistName,
            tags: [],
            sharedTags,
            score,
          });
          processedForTag++;
          if (
            processedForTag >= maxPerTag ||
            recordingCandidates.size >= maxTotalRecordingCandidates
          ) {
            break;
          }
        }
        console.log(
          `Processed tag "${tag.name}" for recording ${recordingMbid}; candidates so far: ${recordingCandidates.size}`,
        );
      }
    }

    // Strategy 2: If we have artist info, search for other recordings by same artist
    if (artistName && recordingCandidates.size < limit) {
      const artistSearchResult = await this.searchEntities({
        query: `artist:"${artistName}"`,
        entityType: "recording",
        limit: 15,
      });

      if (!("error" in artistSearchResult) && artistSearchResult.results) {
        for (const recResult of artistSearchResult.results) {
          if (recResult.id === recordingMbid) continue;
          if (recordingCandidates.has(recResult.id)) continue;

          const candidateArtistCredit = recResult["artist-credit"]?.[0];
          const candidateArtistName = candidateArtistCredit?.name ||
            (candidateArtistCredit as { artist?: { name?: string } })?.artist
              ?.name;

          recordingCandidates.set(recResult.id, {
            title: recResult.title || "Unknown",
            artist: candidateArtistName,
            tags: [],
            sharedTags: new Set(["same artist"]),
            score: 30, // Base score for same artist
          });
        }
      }
    }

    const similarRecordings = Array.from(recordingCandidates.entries())
      .map(([mbid, data]) => ({
        mbid,
        title: data.title,
        artist: data.artist,
        score: Math.round(data.score * 100) / 100,
        sharedGenres: Array.from(data.sharedTags),
      }))
      .sort((a, b) => b.score - a.score)
      .slice(0, limit);

    return { similarRecordings };
  }

  /**
   * getSimilarReleaseGroups(releaseGroupMbid: String, limit: Number): (similarReleaseGroups: List<ReleaseGroup>)
   *
   * requires: releaseGroupMbid is valid
   * effect: finds similar release groups (albums) based on genre/tag overlap and artist similarity. Returns a scored list.
   */
  async getSimilarReleaseGroups(
    { releaseGroupMbid, limit = 10 }: {
      releaseGroupMbid: EntityMbid;
      limit?: number;
    },
  ): Promise<
    {
      similarReleaseGroups?: Array<{
        mbid: string;
        title: string;
        artist?: string;
        score: number;
        sharedGenres: string[];
      }>;
      error?: string;
    }
  > {
    if (!releaseGroupMbid) return { error: "releaseGroupMbid is required." };

    // Step 1: Get the source release group's full details with tags and artist
    const releaseGroupResult = await this.lookupReleaseGroup({
      mbid: releaseGroupMbid,
      includes: ["tags", "artist-credits"],
    });

    if ("error" in releaseGroupResult || !releaseGroupResult.releaseGroup) {
      return { error: "Could not fetch release group details." };
    }

    const sourceReleaseGroup = releaseGroupResult.releaseGroup;
    let tags = (sourceReleaseGroup.tags || []).sort(
      (a: MBTag, b: MBTag) => b.count - a.count,
    );

    // Get artist info for additional context
    const artistCredit = sourceReleaseGroup["artist-credit"]?.[0];
    const artistName = artistCredit?.name || artistCredit?.artist?.name;
    const artistId = artistCredit?.artist?.id;
    console.log("tags for release group ", releaseGroupMbid, ": ", tags);

    // If release-group doesn't have tags, fall back to artist genres
    if (tags.length === 0 && artistId) {
      const artistGenresResult = await this.getEntityGenres({
        mbid: artistId as ID,
        entityType: "artist",
      });

      if (!("error" in artistGenresResult)) {
        tags = [
          ...(artistGenresResult.genres || []),
          ...(artistGenresResult.tags || []),
        ].sort((a: MBTag, b: MBTag) => b.count - a.count);
        console.log(
          "tags for release group ",
          releaseGroupMbid,
          " (from artist fallback): ",
          tags,
        );
      }
    }

    if (tags.length === 0 && !artistId) {
      return {
        similarReleaseGroups: [],
        error: "No genres/tags or artist found for this release group.",
      };
    }

    const releaseGroupCandidates = new Map<
      string,
      {
        title: string;
        artist?: string;
        tags: MBTag[];
        sharedTags: Set<string>;
        score: number;
      }
    >();

    // Strategy 1: Search by tags if available (no per-candidate fetches)
    if (tags.length > 0) {
      const topTags = tags.slice(0, 5);
      const maxTotalReleaseGroupCandidates = limit * 4;
      for (const tag of topTags) {
        const searchResult = await this.searchEntities({
          query: `tag:"${tag.name}"`,
          entityType: "release-group",
          limit: 20,
        });
        if ("error" in searchResult || !searchResult.results) continue;
        let processedForTag = 0;
        const maxPerTag = Math.max(10, limit);
        for (const rgResult of searchResult.results) {
          if (rgResult.id === releaseGroupMbid) continue;

          const candidateArtistCredit = rgResult["artist-credit"]?.[0] as
            | { name?: string; artist?: { name?: string } }
            | undefined;
          const candidateArtistName = candidateArtistCredit?.name ||
            candidateArtistCredit?.artist?.name;

          if (releaseGroupCandidates.has(rgResult.id)) {
            const c = releaseGroupCandidates.get(rgResult.id)!;
            c.sharedTags.add(tag.name);
            c.score += Math.sqrt(tag.count) * 2;
          } else {
            const searchScore = typeof rgResult.score === "number"
              ? rgResult.score
              : parseInt(String(rgResult.score)) || 0;
            let score = Math.sqrt(tag.count) * 2 + (searchScore / 10);
            if (
              artistName && candidateArtistName &&
              artistName.toLowerCase() === candidateArtistName.toLowerCase()
            ) {
              score += 40;
            }
            releaseGroupCandidates.set(rgResult.id, {
              title: rgResult.title || "Unknown",
              artist: candidateArtistName,
              tags: [],
              sharedTags: new Set<string>([tag.name]),
              score,
            });
            processedForTag++;
            if (
              processedForTag >= maxPerTag ||
              releaseGroupCandidates.size >= maxTotalReleaseGroupCandidates
            ) {
              break;
            }
          }
        }
        console.log(
          `Processed tag "${tag.name}" for release-group ${releaseGroupMbid}; candidates: ${releaseGroupCandidates.size}`,
        );
        if (releaseGroupCandidates.size >= maxTotalReleaseGroupCandidates) {
          break;
        }
      }
    }

    // Strategy 2: Same-artist fallback without extra fetches
    if (artistName && releaseGroupCandidates.size < limit) {
      const artistSearchResult = await this.searchEntities({
        query: `artist:"${artistName}"`,
        entityType: "release-group",
        limit: 15,
      });
      if (!("error" in artistSearchResult) && artistSearchResult.results) {
        for (const rgResult of artistSearchResult.results) {
          if (rgResult.id === releaseGroupMbid) continue;
          if (releaseGroupCandidates.has(rgResult.id)) continue;

          const candidateArtistCredit = rgResult["artist-credit"]?.[0] as
            | { name?: string; artist?: { name?: string } }
            | undefined;
          const candidateArtistName = candidateArtistCredit?.name ||
            candidateArtistCredit?.artist?.name;

          releaseGroupCandidates.set(rgResult.id, {
            title: rgResult.title || "Unknown",
            artist: candidateArtistName,
            tags: [],
            sharedTags: new Set<string>(["same artist"]),
            score: 25,
          });
        }
      }
    }

    const similarReleaseGroups = Array.from(releaseGroupCandidates.entries())
      .map(([mbid, data]) => ({
        mbid,
        title: data.title,
        artist: data.artist,
        score: Math.round(data.score * 100) / 100,
        sharedGenres: Array.from(data.sharedTags),
      }))
      .sort((a, b) => b.score - a.score)
      .slice(0, limit);

    return { similarReleaseGroups };
  }

  /**
   * getCoverArt(releaseMbid: String): (coverArtUrl: String)
   *
   * requires: releaseMbid is valid
   * effect: retrieves the cover art URL for a release from Cover Art Archive (integrated with MusicBrainz).
   */
  async getCoverArt(
    { releaseMbid }: { releaseMbid: EntityMbid },
  ): Promise<{ coverArtUrl?: string; error?: string }> {
    if (!releaseMbid) return { error: "releaseMbid is required." };

    const url = new URL(`${COVER_ART_API_BASE_URL}${releaseMbid}/front`);
    // Cover Art Archive doesn't use the same JSON format or caching mechanism as MB API directly,
    // so we'll treat it as a direct fetch for the URL.
    // We could still cache the URL in entityCache if we wanted to avoid repeated HTTP HEAD requests.

    // A HEAD request is often sufficient to check for image existence without downloading
    await this._waitForRateLimit(); // Still apply rate limiting as it's an external API call
    try {
      const response = await fetch(url.toString(), { method: "HEAD" });

      if (response.ok) {
        // If a "front" image exists, return its URL.
        // The actual image is at the same URL if GET is used.
        return { coverArtUrl: url.toString() };
      } else {
        await response.body?.cancel();
        if (response.status === 404) {
          return { error: "Cover art not found for this release." };
        } else {
          throw new Error(
            `Cover Art Archive error: ${response.status} ${response.statusText}`,
          );
        }
      }
    } catch (error: unknown) {
      const errorMessage = error instanceof Error
        ? error.message
        : String(error);
      console.error(
        `MusicBrainzAPI: Error fetching cover art ${url.toString()}:`,
        error,
      );
      return { error: `Failed to fetch cover art: ${errorMessage}` };
    }
  }

  /**
   * clearCache(mbid: String): ()
   *
   * requires: mbid exists in cache
   * effect: removes cached entity and relationship data for the specified MBID,
   * forcing fresh API calls on next request.
   */
  async clearCache(
    { mbid }: { mbid: EntityMbid },
  ): Promise<{ error?: string }> {
    if (!mbid) return { error: "MBID is required." };

    // Delete entries from entity cache where cacheKey contains the mbid
    await this.entityCache.deleteMany({ cacheKey: { $regex: mbid } as any });

    return {};
  }
}
