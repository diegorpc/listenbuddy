import { Collection, Db } from "npm:mongodb";
import { ID } from "@utils/types.ts";
import { freshID } from "@utils/database.ts";

// Declare collection prefix, use concept name
const PREFIX = "MusicBrainzAPI" + ".";

// MusicBrainz API Configuration
const MUSICBRAINZ_API_BASE_URL = "https://musicbrainz.org/ws/2/";
const COVER_ART_API_BASE_URL = "https://coverartarchive.org/release/";
const RATE_LIMIT_DELAY_MS = 1100; // ~1 request per second + buffer
const USER_AGENT = "ListenBuddy/1.0.0 (diegorpc@mit.edu)";

// Generic types of this concept
type EntityMbid = ID;
type EntityType =
  | "artist"
  | "recording"
  | "release"
  | "release-group"
  | "work";

// Detailed MusicBrainz API response types based on actual responses
interface MBLifeSpan {
  begin?: string | null;
  end?: string | null;
  ended: boolean;
}

interface MBArea {
  id: string;
  type?: string | null;
  "type-id"?: string | null;
  name: string;
  "sort-name": string;
  disambiguation?: string;
  "iso-3166-1-codes"?: string[];
  "life-span"?: MBLifeSpan;
}

interface MBArtist {
  id: string;
  name: string;
  "sort-name": string;
  disambiguation?: string;
  type?: string;
  "type-id"?: string;
  "gender"?: string | null;
  "gender-id"?: string | null;
  country?: string;
  area?: MBArea;
  "begin-area"?: MBArea;
  "end-area"?: MBArea | null;
  "life-span"?: MBLifeSpan;
  ipis?: string[];
  isnis?: string[];
  aliases?: MBAlias[];
  tags?: MBTag[];
  relations?: MBRelation[];
  releases?: MBRelease[];
}

interface MBAlias {
  name: string;
  "sort-name": string;
  type?: string;
  "type-id"?: string;
  locale?: string | null;
  primary?: boolean | null;
  "begin-date"?: string | null;
  "end-date"?: string | null;
}

interface MBTag {
  name: string;
  count: number;
}

interface MBArtistCredit {
  name: string;
  artist?: MBArtist;
  joinphrase?: string;
}

interface MBWork {
  id: string;
  title: string;
  type?: string;
  "type-id"?: string;
  disambiguation?: string;
  language?: string;
  languages?: string[];
  iswcs?: string[];
  attributes?: MBWorkAttribute[];
  relations?: MBRelation[];
}

interface MBWorkAttribute {
  type: string;
  "type-id": string;
  value: string;
}

interface MBRecording {
  id: string;
  title: string;
  length?: number;
  disambiguation?: string;
  video?: boolean;
  "artist-credit"?: MBArtistCredit[];
  releases?: MBRelease[];
  isrcs?: string[];
  tags?: MBTag[];
  relations?: MBRelation[];
}

interface MBRelease {
  id: string;
  title: string;
  status?: string;
  "status-id"?: string;
  date?: string;
  country?: string;
  disambiguation?: string;
  barcode?: string | null;
  "artist-credit"?: MBArtistCredit[];
  "release-group"?: MBReleaseGroup;
  media?: MBMedia[];
  "label-info"?: MBLabelInfo[];
  "cover-art-archive"?: MBCoverArtArchive;
  relations?: MBRelation[];
}

interface MBMedia {
  title?: string;
  position: number;
  format?: string;
  "format-id"?: string;
  "track-count": number;
  "track-offset"?: number;
  tracks?: MBTrack[];
}

interface MBTrack {
  id: string;
  position: number;
  number: string;
  title: string;
  length?: number;
  recording?: MBRecording;
  "artist-credit"?: MBArtistCredit[];
}

interface MBReleaseGroup {
  id: string;
  title: string;
  "primary-type"?: string;
  "primary-type-id"?: string;
  "secondary-types"?: string[];
  "secondary-type-ids"?: string[];
  "first-release-date"?: string;
  disambiguation?: string;
  "artist-credit"?: MBArtistCredit[];
  releases?: MBRelease[];
  tags?: MBTag[];
  relations?: MBRelation[];
}

interface MBLabelInfo {
  "catalog-number"?: string;
  label?: MBLabel;
}

interface MBLabel {
  id: string;
  name: string;
  "sort-name": string;
  disambiguation?: string;
  type?: string;
  "type-id"?: string;
}

interface MBCoverArtArchive {
  artwork: boolean;
  count: number;
  front: boolean;
  back: boolean;
  darkened: boolean;
}

interface MBRelation {
  type: string;
  "type-id"?: string;
  "target-type": string;
  "target-credit"?: string;
  "source-credit"?: string;
  direction?: string;
  begin?: string;
  end?: string;
  ended?: boolean;
  attributes?: string[];
  "attribute-values"?: Record<string, string>;
  "attribute-ids"?: Record<string, string>;
  artist?: MBArtist;
  work?: MBWork;
  recording?: MBRecording;
  release?: MBRelease;
  "release-group"?: MBReleaseGroup;
  url?: MBUrl;
  genre?: MBGenre;
}

interface MBUrl {
  id: string;
  resource: string;
}

interface MBGenre {
  id: string;
  name: string;
  disambiguation?: string;
}

interface MBSearchResult {
  score: number;
  id: string;
  name?: string;
  title?: string;
  "sort-name"?: string;
  type?: string;
  "type-id"?: string;
  disambiguation?: string;
  country?: string;
  area?: MBArea;
  "begin-area"?: MBArea;
  "life-span"?: MBLifeSpan;
  isnis?: string[];
  aliases?: MBAlias[];
  tags?: MBTag[];
  "artist-credit"?: MBArtistCredit[];
}

/**
 * A set of EntityCache with:
 *   an _id of type ID (unique identifier generated by freshID)
 *   a cacheKey of type String (full URL used for lookups)
 *   an mbid of type String (MusicBrainz ID)
 *   an entityType of type String ("artist", "recording", "release", "release-group", "work")
 *   a metadata of type JSON
 *   a lastFetched of type Timestamp
 */
interface EntityCache {
  _id: ID; // Unique ID generated by freshID()
  cacheKey: string; // Full URL including query params
  mbid: EntityMbid | string | null; // Can be null for search/browse
  entityType: EntityType | "search" | "browse";
  metadata: any;
  relationships?: any; // For search/browse results
  lastFetched: Date;
}

// In-memory rate limit state for simplicity, can be made persistent if needed for distributed instances
interface RateLimitState {
  lastRequestTime: Date;
}

export default class MusicBrainzAPI {
  private entityCache: Collection<EntityCache>;
  private rateLimitState: RateLimitState;

  // TTL for cache (can be adjusted)
  private static readonly ENTITY_CACHE_TTL_MS = 24 * 60 * 60 * 1000; // 24 hours

  constructor(private readonly db: Db) {
    this.entityCache = this.db.collection(PREFIX + "entityCache");
    this.rateLimitState = { lastRequestTime: new Date(0) }; // Initialize to a past date
  }

  /**
   * Internal helper to enforce MusicBrainz API rate limit (1 request/second).
   * Blocks until enough time has passed since the last request.
   */
  private async _waitForRateLimit(): Promise<void> {
    const now = new Date();
    const timeSinceLastRequest = now.getTime() -
      this.rateLimitState.lastRequestTime.getTime();

    if (timeSinceLastRequest < RATE_LIMIT_DELAY_MS) {
      const delay = RATE_LIMIT_DELAY_MS - timeSinceLastRequest;
      // console.warn(`MusicBrainzAPI: Rate limit hit. Waiting for ${delay}ms.`);
      await new Promise((resolve) => setTimeout(resolve, delay));
    }
    this.rateLimitState.lastRequestTime = new Date(); // Update last request time
  }

  /**
   * Internal helper to make a request to the MusicBrainz API, handling caching and rate limiting.
   * @param entityType The type of entity or request being made.
   * @param mbid The MusicBrainz ID (can be null for search/browse).
   * @param requestUrl The complete URL for the API request.
   * @param cacheCollection The MongoDB collection to use for caching.
   * @param ttlMs Time-to-live for the cache entry in milliseconds.
   * @returns The parsed JSON response or an error object.
   */
  private async _fetchAndCache<T>(
    entityType: EntityType | "search" | "browse",
    mbid: EntityMbid | string | null, // Can be null for search/browse
    requestUrl: URL,
    cacheCollection: Collection<any>,
    ttlMs: number,
  ): Promise<T | { error: string }> {
    // Use full URL as cache key to include query parameters (like inc=releases)
    // This ensures different includes don't share the same cache entry
    const cacheKey = requestUrl.toString();

    // 1. Check cache first
    const cachedData = await cacheCollection.findOne({ cacheKey });

    if (cachedData) {
      if (
        new Date().getTime() - cachedData.lastFetched.getTime() <
          ttlMs
      ) {
        // console.log(`MusicBrainzAPI: Cache hit for ${cacheKey}`);
        return cachedData.metadata || cachedData.relationships;
      } else {
        // console.log(`MusicBrainzAPI: Cache expired for ${cacheKey}`);
        // Optionally delete expired cache here to keep it clean, but usually just overwrite.
      }
    }

    // 2. Enforce rate limit
    await this._waitForRateLimit();

    // 3. Make the API call
    try {
      const response = await fetch(requestUrl.toString(), {
        headers: { "User-Agent": USER_AGENT },
      });

      if (!response.ok) {
        await response.body?.cancel();
        if (response.status === 404 || response.status === 400) {
          return { error: `Entity not found: ${mbid}` };
        }
        throw new Error(
          `MusicBrainz API error: ${response.status} ${response.statusText}`,
        );
      }

      const data = await response.json();

      // 4. Cache the result
      const cacheUpdate: any = {
        cacheKey,
        lastFetched: new Date(),
      };

      if (
        entityType === "artist" ||
        entityType === "recording" ||
        entityType === "release" ||
        entityType === "release-group" ||
        entityType === "work"
      ) {
        Object.assign(cacheUpdate, {
          mbid: mbid,
          entityType: entityType,
          metadata: data,
        });
      } else { // This handles search and browse
        Object.assign(cacheUpdate, {
          mbid: mbid, // Can be null for search/browse but still useful
          entityType: entityType, // Store the type for reference
          metadata: data, // Store full response for search/browse
          relationships: data.relations || data.artists || data.recordings ||
            data.releases || data["release-groups"] || data.works, // Extract specific lists if available
        });
      }

      await cacheCollection.updateOne(
        { cacheKey },
        {
          $set: cacheUpdate,
          $setOnInsert: { _id: freshID() }, // Generate ID only on first insert
        },
        { upsert: true },
      );
      // console.log(`MusicBrainzAPI: Cached ${cacheKey}`);

      // Return the actual data part for different request types
      if (entityType === "search" || entityType === "browse") {
        return cacheUpdate.metadata as T;
      }
      return cacheUpdate.metadata || cacheUpdate.relationships as T;
    } catch (error: any) {
      console.error(
        `MusicBrainzAPI: Error fetching ${requestUrl.toString()}:`,
        error,
      );
      return {
        error: `Failed to fetch from MusicBrainz API: ${error.message}`,
      };
    }
  }

  /**
   * lookupArtist(mbid: String, includes: List<String>): (artist: JSON)
   *
   * requires: mbid is valid MusicBrainz artist ID, includes contains valid subquery types
   * effect: fetches detailed artist information from MusicBrainz API including optional subqueries (recordings, releases, release-groups, works, artist-rels, etc.).
   * Returns artist name, aliases, area, type, and requested linked entities.
   */
  async lookupArtist(
    { mbid, includes = [] }: { mbid: EntityMbid; includes?: string[] },
  ): Promise<{ artist?: MBArtist; error?: string }> {
    if (!mbid) return { error: "MBID is required." };

    const url = new URL(`${MUSICBRAINZ_API_BASE_URL}artist/${mbid}`);
    url.searchParams.set("fmt", "json");
    if (includes.length > 0) {
      url.searchParams.set("inc", includes.join("+"));
    }

    const result = await this._fetchAndCache<any>(
      "artist",
      mbid,
      url,
      this.entityCache,
      MusicBrainzAPI.ENTITY_CACHE_TTL_MS,
    );
    if ("error" in result) return result;
    // MusicBrainz API returns entity data directly at the root
    return { artist: result };
  }

  /**
   * lookupRecording(mbid: String, includes: List<String>): (recording: JSON)
   *
   * requires: mbid is valid MusicBrainz recording ID, includes contains valid subquery types
   * effect: fetches recording (track/song) information including title, length, artists, and optionally releases, ISRCs, work relationships, and artist relationships.
   */
  async lookupRecording(
    { mbid, includes = [] }: { mbid: EntityMbid; includes?: string[] },
  ): Promise<{ recording?: MBRecording; error?: string }> {
    if (!mbid) return { error: "MBID is required." };

    const url = new URL(`${MUSICBRAINZ_API_BASE_URL}recording/${mbid}`);
    url.searchParams.set("fmt", "json");
    if (includes.length > 0) {
      url.searchParams.set("inc", includes.join("+"));
    }

    const result = await this._fetchAndCache<any>(
      "recording",
      mbid,
      url,
      this.entityCache,
      MusicBrainzAPI.ENTITY_CACHE_TTL_MS,
    );
    if ("error" in result) return result;
    // MusicBrainz API returns entity data directly at the root
    return { recording: result };
  }

  /**
   * lookupRelease(mbid: String, includes: List<String>): (release: JSON)
   *
   * requires: mbid is valid MusicBrainz release ID, includes contains valid subquery types
   * effect: fetches release (album) information including title, date, status, artists, labels, and optionally recordings, release-group, cover art, and relationships.
   */
  async lookupRelease(
    { mbid, includes = [] }: { mbid: EntityMbid; includes?: string[] },
  ): Promise<{ release?: MBRelease; error?: string }> {
    if (!mbid) return { error: "MBID is required." };

    const url = new URL(`${MUSICBRAINZ_API_BASE_URL}release/${mbid}`);
    url.searchParams.set("fmt", "json");
    if (includes.length > 0) {
      url.searchParams.set("inc", includes.join("+"));
    }

    const result = await this._fetchAndCache<any>(
      "release",
      mbid,
      url,
      this.entityCache,
      MusicBrainzAPI.ENTITY_CACHE_TTL_MS,
    );
    if ("error" in result) return result;
    // MusicBrainz API returns entity data directly at the root
    return { release: result };
  }

  /**
   * lookupReleaseGroup(mbid: String, includes: List<String>): (releaseGroup: JSON)
   *
   * requires: mbid is valid MusicBrainz release-group ID, includes contains valid subquery types
   * effect: fetches release group information including title, type, artists, and optionally individual releases and relationships.
   */
  async lookupReleaseGroup(
    { mbid, includes = [] }: { mbid: EntityMbid; includes?: string[] },
  ): Promise<{ releaseGroup?: MBReleaseGroup; error?: string }> {
    if (!mbid) return { error: "MBID is required." };

    const url = new URL(`${MUSICBRAINZ_API_BASE_URL}release-group/${mbid}`);
    url.searchParams.set("fmt", "json");
    if (includes.length > 0) {
      url.searchParams.set("inc", includes.join("+"));
    }

    const result = await this._fetchAndCache<any>(
      "release-group",
      mbid,
      url,
      this.entityCache,
      MusicBrainzAPI.ENTITY_CACHE_TTL_MS,
    );
    if ("error" in result) return result;
    // MusicBrainz API returns entity data directly at the root
    return { releaseGroup: result };
  }

  /**
   * lookupWork(mbid: String, includes: List<String>): (work: JSON)
   *
   * requires: mbid is valid MusicBrainz work ID, includes contains valid subquery types
   * effect: fetches work (composition) information including title, type, and relationships to artists (composers, lyricists), recordings, and other works.
   */
  async lookupWork(
    { mbid, includes = [] }: { mbid: EntityMbid; includes?: string[] },
  ): Promise<{ work?: MBWork; error?: string }> {
    if (!mbid) return { error: "MBID is required." };

    const url = new URL(`${MUSICBRAINZ_API_BASE_URL}work/${mbid}`);
    url.searchParams.set("fmt", "json");
    if (includes.length > 0) {
      url.searchParams.set("inc", includes.join("+"));
    }

    const result = await this._fetchAndCache<any>(
      "work",
      mbid,
      url,
      this.entityCache,
      MusicBrainzAPI.ENTITY_CACHE_TTL_MS,
    );
    if ("error" in result) return result;
    // MusicBrainz API returns entity data directly at the root
    return { work: result };
  }

  /**
   * searchEntities(query: String, entityType: String, limit: Number): (results: List<JSON>)
   *
   * requires: query is non-empty, entityType is valid ("artist", "recording", "release", etc.), limit is positive
   * effect: searches MusicBrainz database for entities matching the query string. Returns ranked list of matching entities with scores.
   */
  async searchEntities(
    { query, entityType, limit = 25 }: {
      query: string;
      entityType: EntityType;
      limit?: number;
    },
  ): Promise<{ results?: MBSearchResult[]; error?: string }> {
    if (!query || query.trim() === "") {
      return { error: "Query cannot be empty." };
    }
    if (
      !["artist", "recording", "release", "release-group", "work"].includes(
        entityType,
      )
    ) {
      return { error: "Invalid entityType." };
    }
    if (limit <= 0) return { error: "Limit must be positive." };

    const url = new URL(`${MUSICBRAINZ_API_BASE_URL}${entityType}`);
    url.searchParams.set("fmt", "json");
    url.searchParams.set("query", query);
    url.searchParams.set("limit", limit.toString());

    const result = await this._fetchAndCache<any>(
      "search",
      null, // No specific MBID for search
      url,
      this.entityCache, // Using entityCache for search results as well
      MusicBrainzAPI.ENTITY_CACHE_TTL_MS,
    );
    if ("error" in result) return result;

    // MusicBrainz search results are typically under an array key matching the entity type (e.g., 'artists', 'recordings')
    // Handle special case for release-group which becomes release-groups in the API response
    const entityKey = entityType === "release-group"
      ? "release-groups"
      : `${entityType}s`;
    return { results: result[entityKey] || [] };
  }

  /**
   * browseByEntity(entityType: String, linkedEntity: String, linkedMbid: String, limit: Number, offset: Number): (results: List<JSON>)
   *
   * requires: entityType and linkedEntity are valid types, linkedMbid exists, limit and offset are non-negative
   * effect: browses entities linked to a specific entity (e.g., all releases by an artist, all recordings of a work). Supports pagination.
   */
  async browseByEntity(
    { entityType, linkedEntity, linkedMbid, limit = 25, offset = 0 }: {
      entityType: EntityType;
      linkedEntity: EntityType;
      linkedMbid: EntityMbid;
      limit?: number;
      offset?: number;
    },
  ): Promise<
    {
      results?:
        (MBArtist | MBRecording | MBRelease | MBReleaseGroup | MBWork)[];
      error?: string;
    }
  > {
    if (!linkedMbid) return { error: "linkedMbid is required." };
    if (
      !["artist", "recording", "release", "release-group", "work"].includes(
        entityType,
      )
    ) {
      return { error: "Invalid entityType." };
    }
    if (
      !["artist", "recording", "release", "release-group", "work"].includes(
        linkedEntity,
      )
    ) {
      return { error: "Invalid linkedEntity type." };
    }
    if (limit < 0 || offset < 0) {
      return { error: "Limit and offset must be non-negative." };
    }

    const url = new URL(`${MUSICBRAINZ_API_BASE_URL}${entityType}`);
    url.searchParams.set("fmt", "json");
    url.searchParams.set(linkedEntity, linkedMbid); // e.g., ?artist={mbid}
    url.searchParams.set("limit", limit.toString());
    url.searchParams.set("offset", offset.toString());

    const result = await this._fetchAndCache<any>(
      "browse",
      linkedMbid, // Use linkedMbid as a context for caching
      url,
      this.entityCache,
      MusicBrainzAPI.ENTITY_CACHE_TTL_MS,
    );
    if ("error" in result) return result;

    // Handle special case for release-group which becomes release-groups in the API response
    const entityKey = entityType === "release-group"
      ? "release-groups"
      : `${entityType}s`;
    return { results: result[entityKey] || [] };
  }

  /**
   * getEntityGenres(mbid: String, entityType: String): (genres: List<Genre>)
   *
   * requires: mbid is valid, entityType is supported
   * effect: fetches genres (and tags) for an entity and returns them sorted by count/relevance.
   * Useful for finding similar entities based on genre overlap.
   */
  async getEntityGenres(
    { mbid, entityType }: { mbid: EntityMbid; entityType: EntityType },
  ): Promise<{ genres?: MBTag[]; tags?: MBTag[]; error?: string }> {
    if (!mbid) return { error: "MBID is required." };
    if (
      !["artist", "recording", "release", "release-group"].includes(
        entityType,
      )
    ) {
      return { error: "Invalid entityType for genre lookup." };
    }

    const url = new URL(`${MUSICBRAINZ_API_BASE_URL}${entityType}/${mbid}`);
    url.searchParams.set("fmt", "json");
    url.searchParams.set("inc", "genres+tags");

    const result = await this._fetchAndCache<any>(
      entityType,
      mbid,
      url,
      this.entityCache,
      MusicBrainzAPI.ENTITY_CACHE_TTL_MS,
    );

    if ("error" in result) return result;

    // Extract and sort genres and tags by count (descending)
    const genres = (result.genres || []).sort(
      (a: MBTag, b: MBTag) => b.count - a.count,
    );
    const tags = (result.tags || []).sort(
      (a: MBTag, b: MBTag) => b.count - a.count,
    );

    return { genres, tags };
  }

  /**
   * getArtistSimilarities(artistMbid: String, limit: Number): (similarArtists: List<Artist>)
   *
   * requires: artistMbid is valid
   * effect: finds similar artists based on genre/tag overlap. Fetches the artist's top genres,
   * searches for other artists with those genres, and returns a scored list of similar artists.
   * This is more useful for recommendations than relationship-based approaches.
   */
  async getArtistSimilarities(
    { artistMbid, limit = 10 }: { artistMbid: EntityMbid; limit?: number },
  ): Promise<
    {
      similarArtists?: Array<{
        mbid: string;
        name: string;
        score: number;
        sharedGenres: string[];
      }>;
      error?: string;
    }
  > {
    if (!artistMbid) return { error: "artistMbid is required." };

    // Step 1: Get the artist's genres and tags
    const genreResult = await this.getEntityGenres({
      mbid: artistMbid,
      entityType: "artist",
    });

    if ("error" in genreResult) return genreResult;

    const genres = genreResult.genres || [];
    const tags = genreResult.tags || [];

    // Combine genres and tags, prioritizing genres (they're curated)
    const allTags = [...genres, ...tags];

    if (allTags.length === 0) {
      return {
        similarArtists: [],
        error:
          "No genres or tags found for this artist. Cannot compute similarities.",
      };
    }

    // Step 2: Take top genres/tags (weighted by count)
    const topGenres = allTags.slice(0, 5).map((g) => g.name);

    // Step 3: Search for artists with similar genres
    // We'll search for each top genre and aggregate results
    const artistCandidates = new Map<
      string,
      { name: string; genres: Set<string>; score: number }
    >();

    for (const genre of topGenres) {
      // Search for artists with this genre in their name/tags
      // Note: MusicBrainz search doesn't support direct genre filtering,
      // so we search by tag name and filter results
      const searchResult = await this.searchEntities({
        query: `tag:${genre}`,
        entityType: "artist",
        limit: 20,
      });

      if ("error" in searchResult || !searchResult.results) continue;

      // For each artist found, check their actual genres
      for (const artistResult of searchResult.results) {
        // Skip the original artist
        if (artistResult.id === artistMbid) continue;

        if (!artistCandidates.has(artistResult.id)) {
          artistCandidates.set(artistResult.id, {
            name: artistResult.name || "Unknown",
            genres: new Set(),
            score: 0,
          });
        }

        const candidate = artistCandidates.get(artistResult.id)!;
        candidate.genres.add(genre);
        // Score is based on number of shared genres and the genre's weight
        const genreWeight = allTags.find((t) => t.name === genre)?.count || 1;
        candidate.score += genreWeight;
      }
    }

    // Step 4: Sort by score and format results
    const similarArtists = Array.from(artistCandidates.entries())
      .map(([mbid, data]) => ({
        mbid,
        name: data.name,
        score: data.score,
        sharedGenres: Array.from(data.genres),
      }))
      .sort((a, b) => b.score - a.score)
      .slice(0, limit);

    return { similarArtists };
  }

  /**
   * getRecordingWorks(recordingMbid: String): (works: List<Work>)
   *
   * requires: recordingMbid is valid
   * effect: fetches the musical works (compositions) associated with a recording,
   * including composer and lyricist information.
   */
  async getRecordingWorks(
    { recordingMbid }: { recordingMbid: EntityMbid },
  ): Promise<{ works?: any[]; error?: string }> {
    if (!recordingMbid) return { error: "recordingMbid is required." };

    const recordingResult = await this.lookupRecording({
      mbid: recordingMbid,
      includes: ["work-rels"],
    });

    if ("error" in recordingResult) return recordingResult;

    const recording = recordingResult.recording;
    if (!recording) return { error: "Recording data not found." };
    const associatedWorks: any[] = [];

    if (recording.relations) {
      for (const rel of recording.relations) {
        if (
          rel.type === "performance" && rel["target-type"] === "work" &&
          rel.work
        ) {
          // Fetch full work details with artist relationships
          const workResult = await this.lookupWork({
            mbid: rel.work.id as ID,
            includes: ["artist-rels"],
          });

          if ("error" in workResult) continue; // Skip works that fail to fetch

          const workData = workResult.work;
          if (!workData) continue;
          const artists: any[] = [];

          // Extract composer and lyricist relationships from work
          if (workData.relations) {
            for (const wrel of workData.relations) {
              if (
                wrel["target-type"] === "artist" &&
                ["composer", "lyricist"].includes(wrel.type) &&
                wrel.artist
              ) {
                artists.push({
                  mbid: wrel.artist.id,
                  name: wrel.artist.name,
                  type: wrel.type,
                });
              }
            }
          }

          const work = {
            mbid: workData.id,
            title: workData.title,
            type: workData.type,
            artists: artists,
          };
          associatedWorks.push(work);
        }
      }
    }

    return { works: associatedWorks };
  }

  /**
   * getSimilarRecordings(recordingMbid: String, limit: Number): (similarRecordings: List<Recording>)
   *
   * requires: recordingMbid is valid
   * effect: finds similar recordings based on genre/tag overlap. Returns a scored list of similar recordings.
   */
  async getSimilarRecordings(
    { recordingMbid, limit = 10 }: {
      recordingMbid: EntityMbid;
      limit?: number;
    },
  ): Promise<
    {
      similarRecordings?: Array<{
        mbid: string;
        title: string;
        score: number;
        sharedGenres: string[];
      }>;
      error?: string;
    }
  > {
    if (!recordingMbid) return { error: "recordingMbid is required." };

    const genreResult = await this.getEntityGenres({
      mbid: recordingMbid,
      entityType: "recording",
    });

    if ("error" in genreResult) return genreResult;

    const genres = genreResult.genres || [];
    const tags = genreResult.tags || [];
    const allTags = [...genres, ...tags];

    if (allTags.length === 0) {
      return {
        similarRecordings: [],
        error: "No genres or tags found for this recording.",
      };
    }

    const topGenres = allTags.slice(0, 5).map((g) => g.name);
    const recordingCandidates = new Map<
      string,
      { title: string; genres: Set<string>; score: number }
    >();

    for (const genre of topGenres) {
      const searchResult = await this.searchEntities({
        query: `tag:${genre}`,
        entityType: "recording",
        limit: 20,
      });

      if ("error" in searchResult || !searchResult.results) continue;

      for (const recordingResult of searchResult.results) {
        if (recordingResult.id === recordingMbid) continue;

        if (!recordingCandidates.has(recordingResult.id)) {
          recordingCandidates.set(recordingResult.id, {
            title: recordingResult.title || "Unknown",
            genres: new Set(),
            score: 0,
          });
        }

        const candidate = recordingCandidates.get(recordingResult.id)!;
        candidate.genres.add(genre);
        const genreWeight = allTags.find((t) => t.name === genre)?.count || 1;
        candidate.score += genreWeight;
      }
    }

    const similarRecordings = Array.from(recordingCandidates.entries())
      .map(([mbid, data]) => ({
        mbid,
        title: data.title,
        score: data.score,
        sharedGenres: Array.from(data.genres),
      }))
      .sort((a, b) => b.score - a.score)
      .slice(0, limit);

    return { similarRecordings };
  }

  /**
   * getSimilarReleaseGroups(releaseGroupMbid: String, limit: Number): (similarReleaseGroups: List<ReleaseGroup>)
   *
   * requires: releaseGroupMbid is valid
   * effect: finds similar release groups (albums) based on genre/tag overlap. Returns a scored list.
   */
  async getSimilarReleaseGroups(
    { releaseGroupMbid, limit = 10 }: {
      releaseGroupMbid: EntityMbid;
      limit?: number;
    },
  ): Promise<
    {
      similarReleaseGroups?: Array<{
        mbid: string;
        title: string;
        score: number;
        sharedGenres: string[];
      }>;
      error?: string;
    }
  > {
    if (!releaseGroupMbid) return { error: "releaseGroupMbid is required." };

    const genreResult = await this.getEntityGenres({
      mbid: releaseGroupMbid,
      entityType: "release-group",
    });

    if ("error" in genreResult) return genreResult;

    const genres = genreResult.genres || [];
    const tags = genreResult.tags || [];
    const allTags = [...genres, ...tags];

    if (allTags.length === 0) {
      return {
        similarReleaseGroups: [],
        error: "No genres or tags found for this release group.",
      };
    }

    const topGenres = allTags.slice(0, 5).map((g) => g.name);
    const releaseGroupCandidates = new Map<
      string,
      { title: string; genres: Set<string>; score: number }
    >();

    for (const genre of topGenres) {
      const searchResult = await this.searchEntities({
        query: `tag:${genre}`,
        entityType: "release-group",
        limit: 20,
      });

      if ("error" in searchResult || !searchResult.results) continue;

      for (const rgResult of searchResult.results) {
        if (rgResult.id === releaseGroupMbid) continue;

        if (!releaseGroupCandidates.has(rgResult.id)) {
          releaseGroupCandidates.set(rgResult.id, {
            title: rgResult.title || "Unknown",
            genres: new Set(),
            score: 0,
          });
        }

        const candidate = releaseGroupCandidates.get(rgResult.id)!;
        candidate.genres.add(genre);
        const genreWeight = allTags.find((t) => t.name === genre)?.count || 1;
        candidate.score += genreWeight;
      }
    }

    const similarReleaseGroups = Array.from(releaseGroupCandidates.entries())
      .map(([mbid, data]) => ({
        mbid,
        title: data.title,
        score: data.score,
        sharedGenres: Array.from(data.genres),
      }))
      .sort((a, b) => b.score - a.score)
      .slice(0, limit);

    return { similarReleaseGroups };
  }

  /**
   * getCoverArt(releaseMbid: String): (coverArtUrl: String)
   *
   * requires: releaseMbid is valid
   * effect: retrieves the cover art URL for a release from Cover Art Archive (integrated with MusicBrainz).
   */
  async getCoverArt(
    { releaseMbid }: { releaseMbid: EntityMbid },
  ): Promise<{ coverArtUrl?: string; error?: string }> {
    if (!releaseMbid) return { error: "releaseMbid is required." };

    const url = new URL(`${COVER_ART_API_BASE_URL}${releaseMbid}/front`);
    // Cover Art Archive doesn't use the same JSON format or caching mechanism as MB API directly,
    // so we'll treat it as a direct fetch for the URL.
    // We could still cache the URL in entityCache if we wanted to avoid repeated HTTP HEAD requests.

    // A HEAD request is often sufficient to check for image existence without downloading
    await this._waitForRateLimit(); // Still apply rate limiting as it's an external API call
    try {
      const response = await fetch(url.toString(), { method: "HEAD" });

      if (response.ok) {
        // If a "front" image exists, return its URL.
        // The actual image is at the same URL if GET is used.
        return { coverArtUrl: url.toString() };
      } else {
        await response.body?.cancel();
        if (response.status === 404) {
          return { error: "Cover art not found for this release." };
        } else {
          throw new Error(
            `Cover Art Archive error: ${response.status} ${response.statusText}`,
          );
        }
      }
    } catch (error: any) {
      console.error(
        `MusicBrainzAPI: Error fetching cover art ${url.toString()}:`,
        error,
      );
      return { error: `Failed to fetch cover art: ${error.message}` };
    }
  }

  /**
   * clearCache(mbid: String): ()
   *
   * requires: mbid exists in cache
   * effect: removes cached entity and relationship data for the specified MBID,
   * forcing fresh API calls on next request.
   */
  async clearCache(
    { mbid }: { mbid: EntityMbid },
  ): Promise<{ error?: string }> {
    if (!mbid) return { error: "MBID is required." };

    // Delete entries from entity cache where cacheKey contains the mbid
    await this.entityCache.deleteMany({ cacheKey: { $regex: mbid } as any });

    return {};
  }
}
