---
timestamp: 'Sat Oct 18 2025 22:36:20 GMT-0400 (Eastern Daylight Time)'
parent: '[[..\20251018_223620.4150ca64.md]]'
content_id: a5efc1c67268dc7fd97f07b132e20de4c11d0d36c9addc2fec9ebb2c11b1d068
---

# file: src/MusicBrainzAPI/MusicBrainzAPI.ts

```typescript
import { Collection, Db, MongoClient } from "npm:mongodb";
import { Empty, ID } from "@utils/types.ts";
import { freshID } from "@utils/database.ts";

// Declare collection prefix, use concept name
const PREFIX = "MusicBrainzAPI" + ".";

// --- Configuration ---
const MUSICBRAINZ_API_BASE_URL = "https://musicbrainz.org/ws/2/";
const COVERART_ARCHIVE_API_BASE_URL = "https://coverartarchive.org/release/";
const RATE_LIMIT_MS = 1000; // 1 request per second

// --- Utility Interfaces for MusicBrainz Data ---
export interface MusicBrainzTag {
  name: string;
  count: number;
}

export interface MusicBrainzGenre {
  name: string;
  count: number;
}

export interface MusicBrainzEntity {
  id: string; // MBID
  type?: string;
  name?: string; // For artist, work
  title?: string; // For recording, release, release-group
  disambiguation?: string;
  "life-span"?: {
    begin?: string;
    end?: string;
    ended?: boolean;
  };
  tags?: MusicBrainzTag[];
  genres?: MusicBrainzGenre[];
  "artist-credits"?: Array<{
    artist: { id: string; name: string };
    name: string;
    joinphrase: string;
  }>;
  releases?: MusicBrainzEntity[]; // For artist lookup
  recordings?: MusicBrainzEntity[]; // For release lookup
  works?: MusicBrainzEntity[]; // For recording lookup
  // Add other common fields as needed
  [key: string]: unknown; // Allow for arbitrary additional fields
}

export interface SimilarArtist {
  mbid: string;
  name: string;
  score: number;
  genres: string[];
}

export interface SimilarRecording {
  mbid: string;
  name: string;
  score: number;
  genres: string[];
}

export interface SimilarReleaseGroup {
  mbid: string;
  name: string;
  score: number;
  genres: string[];
}

// --- Concept State Interfaces ---

/**
 * A set of `EntityCache` with:
 *   an `_id` of type `ID` (unique identifier generated by freshID)
 *   a `cacheKey` of type `String` (full URL including query params for lookups)
 *   an `mbid` of type `String` (MusicBrainz ID, can be null for search/browse)
 *   an `entityType` of type `String` ("artist", "recording", "release", "release-group", "work", "search", "browse")
 *   a `metadata` of type `JSON` (includes genres, tags, and other entity data)
 *   a `lastFetched` of type `Timestamp`
 */
interface EntityCacheDoc {
  _id: ID;
  cacheKey: string;
  mbid: string | null;
  entityType: string;
  metadata: Record<string, unknown>; // Store the raw JSON response
  lastFetched: Date;
}

/**
 * A configuration `rateLimitState` with:
 *   a `lastRequestTime` of type `Timestamp`
 */
interface RateLimitStateDoc {
  _id: ID;
  lastRequestTime: Date;
}

export default class MusicBrainzAPI {
  // Purpose: retrieve detailed metadata and genre/tag information for music entities to enable rich recommendations and comprehensive music information display

  private entityCache: Collection<EntityCacheDoc>;
  private rateLimitState: Collection<RateLimitStateDoc>;
  private client: MongoClient | null = null; // Store client to ensure we only have one

  constructor(private readonly db: Db) {
    this.entityCache = this.db.collection(PREFIX + "entityCache");
    this.rateLimitState = this.db.collection(PREFIX + "rateLimitState");

    // Ensure the rate limit state exists
    this.rateLimitState.updateOne(
      { _id: "globalRateLimit" as ID },
      { $setOnInsert: { _id: "globalRateLimit" as ID, lastRequestTime: new Date(0) } },
      { upsert: true },
    );
  }

  /**
   * Internal helper to enforce rate limiting for MusicBrainz API calls.
   * Ensures at least `RATE_LIMIT_MS` has passed since the last request.
   */
  private async _throttle(): Promise<void> {
    const rateLimitDoc = await this.rateLimitState.findOne({
      _id: "globalRateLimit" as ID,
    });
    const lastRequestTime = rateLimitDoc?.lastRequestTime.getTime() || 0;
    const now = Date.now();
    const timeSinceLastRequest = now - lastRequestTime;

    if (timeSinceLastRequest < RATE_LIMIT_MS) {
      const waitTime = RATE_LIMIT_MS - timeSinceLastRequest;
      // console.log(`Throttling: Waiting ${waitTime}ms for MusicBrainz API.`);
      await new Promise((resolve) => setTimeout(resolve, waitTime));
    }

    // Update last request time *before* making the actual fetch,
    // to correctly account for the duration of the fetch itself.
    await this.rateLimitState.updateOne(
      { _id: "globalRateLimit" as ID },
      { $set: { lastRequestTime: new Date() } },
    );
  }

  /**
   * Internal helper to make an API call to MusicBrainz, handling caching and rate limiting.
   */
  private async _callApi<T>(
    path: string,
    params: Record<string, unknown> = {},
    cacheTTLHours: number = 24, // Default cache for 24 hours
  ): Promise<{ data?: T; error?: string }> {
    const query = new URLSearchParams({
      fmt: "json", // Always request JSON format
      ...params,
    }).toString();
    const url = `${MUSICBRAINZ_API_BASE_URL}${path}?${query}`;
    const cacheKey = url;
    const now = new Date();

    // 1. Check Cache
    const cached = await this.entityCache.findOne({ cacheKey });
    if (cached && (now.getTime() - cached.lastFetched.getTime()) <
      cacheTTLHours * 60 * 60 * 1000) {
      // console.log(`Cache hit for ${url}`);
      return { data: cached.metadata as T };
    }

    // 2. Enforce Rate Limit
    await this._throttle();

    // 3. Make API Call
    try {
      // console.log(`Fetching from MusicBrainz: ${url}`);
      const response = await fetch(url, {
        headers: { "User-Agent": "ListenBuddy/1.0 (contact@example.com)" }, // MusicBrainz requires a User-Agent
      });

      if (!response.ok) {
        const errorText = await response.text();
        console.error(`MusicBrainz API error (${response.status}): ${errorText}`);
        return { error: `MusicBrainz API error: ${response.statusText}` };
      }

      const data = await response.json();

      // 4. Store in Cache
      await this.entityCache.updateOne(
        { cacheKey },
        {
          $set: {
            mbid: (params.mbid as string) || null, // Store MBID if it's a lookup
            entityType: path.split("/")[0], // e.g., 'artist', 'recording'
            metadata: data,
            lastFetched: now,
          },
          $setOnInsert: { _id: freshID() },
        },
        { upsert: true },
      );

      return { data: data as T };
    } catch (e) {
      console.error(`Error fetching from MusicBrainz API for ${url}:`, e);
      return { error: `Network error or invalid response: ${e.message}` };
    }
  }

  /**
   * Helper to fetch genres/tags and return them as lists.
   */
  private _extractGenresAndTags(
    entity: MusicBrainzEntity,
  ): { genres: MusicBrainzGenre[]; tags: MusicBrainzTag[] } {
    const genres: MusicBrainzGenre[] =
      (entity.genres as MusicBrainzGenre[] | undefined)?.sort((a, b) =>
        b.count - a.count
      ) || [];
    const tags: MusicBrainzTag[] =
      (entity.tags as MusicBrainzTag[] | undefined)?.sort((a, b) =>
        b.count - a.count
      ) || [];
    return { genres, tags };
  }

  /**
   * lookupArtist(mbid: String, includes: List<String>): (artist: JSON)
   *
   * @requires mbid is valid MusicBrainz artist ID, includes contains valid subquery types
   * @effect fetches detailed artist information from MusicBrainz API including optional subqueries
   *         (recordings, releases, release-groups, works, artist-rels, etc.). Returns artist name,
   *         aliases, area, type, and requested linked entities.
   */
  async lookupArtist(
    params: { mbid: string; includes?: string[] },
  ): Promise<{ artist?: MusicBrainzEntity; error?: string }> {
    const { mbid, includes = [] } = params;
    if (!mbid) return { error: "Artist MBID is required." };
    const { data, error } = await this._callApi<MusicBrainzEntity>(
      `artist/${mbid}`,
      { inc: includes.join("+") },
    );
    return data ? { artist: data } : { error };
  }

  /**
   * lookupRecording(mbid: String, includes: List<String>): (recording: JSON)
   *
   * @requires mbid is valid MusicBrainz recording ID, includes contains valid subquery types
   * @effect fetches recording (track/song) information including title, length, artists, and optionally
   *         releases, ISRCs, work relationships, and artist relationships.
   */
  async lookupRecording(
    params: { mbid: string; includes?: string[] },
  ): Promise<{ recording?: MusicBrainzEntity; error?: string }> {
    const { mbid, includes = [] } = params;
    if (!mbid) return { error: "Recording MBID is required." };
    const { data, error } = await this._callApi<MusicBrainzEntity>(
      `recording/${mbid}`,
      { inc: includes.join("+") },
    );
    return data ? { recording: data } : { error };
  }

  /**
   * lookupRelease(mbid: String, includes: List<String>): (release: JSON)
   *
   * @requires mbid is valid MusicBrainz release ID, includes contains valid subquery types
   * @effect fetches release (album) information including title, date, status, artists, labels, and optionally
   *         recordings, release-group, cover art, and relationships.
   */
  async lookupRelease(
    params: { mbid: string; includes?: string[] },
  ): Promise<{ release?: MusicBrainzEntity; error?: string }> {
    const { mbid, includes = [] } = params;
    if (!mbid) return { error: "Release MBID is required." };
    const { data, error } = await this._callApi<MusicBrainzEntity>(
      `release/${mbid}`,
      { inc: includes.join("+") },
    );
    return data ? { release: data } : { error };
  }

  /**
   * lookupReleaseGroup(mbid: String, includes: List<String>): (releaseGroup: JSON)
   *
   * @requires mbid is valid MusicBrainz release-group ID, includes contains valid subquery types
   * @effect fetches release group information including title, type, artists, and optionally individual
   *         releases and relationships.
   */
  async lookupReleaseGroup(
    params: { mbid: string; includes?: string[] },
  ): Promise<{ releaseGroup?: MusicBrainzEntity; error?: string }> {
    const { mbid, includes = [] } = params;
    if (!mbid) return { error: "Release Group MBID is required." };
    const { data, error } = await this._callApi<MusicBrainzEntity>(
      `release-group/${mbid}`,
      { inc: includes.join("+") },
    );
    return data ? { releaseGroup: data } : { error };
  }

  /**
   * lookupWork(mbid: String, includes: List<String>): (work: JSON)
   *
   * @requires mbid is valid MusicBrainz work ID, includes contains valid subquery types
   * @effect fetches work (composition) information including title, type, and relationships to artists
   *         (composers, lyricists), recordings, and other works.
   */
  async lookupWork(
    params: { mbid: string; includes?: string[] },
  ): Promise<{ work?: MusicBrainzEntity; error?: string }> {
    const { mbid, includes = [] } = params;
    if (!mbid) return { error: "Work MBID is required." };
    const { data, error } = await this._callApi<MusicBrainzEntity>(
      `work/${mbid}`,
      { inc: includes.join("+") },
    );
    return data ? { work: data } : { error };
  }

  /**
   * getEntityGenres(mbid: String, entityType: String): (genres: List<Genre>, tags: List<Tag>)
   *
   * @requires mbid is valid, entityType is one of "artist", "recording", "release", or "release-group"
   * @effect fetches genres (curated) and tags (user-submitted) for an entity, sorted by popularity count.
   *         Used to understand the musical style and find similar content.
   */
  async getEntityGenres(
    params: { mbid: string; entityType: string },
  ): Promise<
    { genres?: MusicBrainzGenre[]; tags?: MusicBrainzTag[]; error?: string }
  > {
    const { mbid, entityType } = params;
    if (!mbid || !entityType) {
      return { error: "MBID and entityType are required." };
    }
    const validTypes = ["artist", "recording", "release", "release-group"];
    if (!validTypes.includes(entityType)) {
      return { error: `Invalid entityType: ${entityType}` };
    }

    const { data, error } = await this._callApi<MusicBrainzEntity>(
      `${entityType}/${mbid}`,
      { inc: "genres+tags" },
    );

    if (error) return { error };
    if (!data) return { error: "No data found for entity." };

    const { genres, tags } = this._extractGenresAndTags(data);
    return { genres, tags };
  }

  /**
   * searchEntities(query: String, entityType: String, limit: Number): (results: List<JSON>)
   *
   * @requires query is non-empty, entityType is valid ("artist", "recording", "release", etc.), limit is positive
   * @effect searches MusicBrainz database for entities matching the query string. Returns ranked list of
   *         matching entities with scores.
   */
  async searchEntities(
    params: { query: string; entityType: string; limit: number },
  ): Promise<{ results?: MusicBrainzEntity[]; error?: string }> {
    const { query, entityType, limit } = params;
    if (!query || !entityType || limit <= 0) {
      return { error: "Query, entityType, and positive limit are required." };
    }
    const { data, error } = await this._callApi<{ [key: string]: MusicBrainzEntity[] }>(
      entityType,
      { query, limit },
    );
    if (error) return { error };

    const resultsKey = `${entityType}s`; // e.g., 'artists', 'recordings'
    return data ? { results: data[resultsKey] } : { error: "No search results." };
  }

  /**
   * browseByEntity(entityType: String, linkedEntity: String, linkedMbid: String, limit: Number, offset: Number): (results: List<JSON>)
   *
   * @requires entityType and linkedEntity are valid types, linkedMbid exists, limit and offset are non-negative
   * @effect browses entities linked to a specific entity (e.g., all releases by an artist, all recordings of a work).
   *         Supports pagination.
   */
  async browseByEntity(
    params: {
      entityType: string;
      linkedEntity: string; // e.g., "artist"
      linkedMbid: string; // e.g., artist MBID
      limit?: number;
      offset?: number;
    },
  ): Promise<{ results?: MusicBrainzEntity[]; error?: string }> {
    const { entityType, linkedEntity, linkedMbid, limit = 25, offset = 0 } =
      params;
    if (!entityType || !linkedEntity || !linkedMbid || limit < 0 || offset < 0) {
      return { error: "Invalid browse parameters." };
    }

    const browseParams: Record<string, unknown> = { limit, offset };
    browseParams[linkedEntity] = linkedMbid; // e.g., artist=mbid

    const { data, error } = await this._callApi<{ [key: string]: MusicBrainzEntity[] }>(
      `${entityType}/`,
      browseParams,
    );
    if (error) return { error };

    const resultsKey = `${entityType}s`;
    return data ? { results: data[resultsKey] } : { error: "No browse results." };
  }

  /**
   * getArtistSimilarities(artistMbid: String, limit: Number): (similarArtists: List<SimilarArtist>)
   *
   * @requires artistMbid is valid
   * @effect finds similar artists based on genre/tag overlap. Returns scored list of artists with shared genres,
   *         where score is weighted by genre popularity. More useful for recommendations than relationship-based approaches.
   */
  async getArtistSimilarities(
    params: { artistMbid: string; limit?: number },
  ): Promise<{ similarArtists?: SimilarArtist[]; error?: string }> {
    const { artistMbid, limit = 10 } = params;
    if (!artistMbid) return { error: "Artist MBID is required." };

    // Get genres/tags for the source artist
    const sourceGenresResult = await this.getEntityGenres({
      mbid: artistMbid,
      entityType: "artist",
    });
    if (sourceGenresResult.error || !sourceGenresResult.genres?.length) {
      return { error: sourceGenresResult.error || "Could not fetch source artist genres." };
    }
    const sourceGenreNames = new Set(sourceGenresResult.genres.map((g) => g.name.toLowerCase()));

    // Find other artists and compare their genres (this would ideally involve a broader search or pre-indexed data)
    // For simplicity, we'll search for artists with common genres. In a real system, you'd pre-index all artist genres.
    // This is a simplified simulation for the concept.
    const searchResult = await this.searchEntities({
      query: Array.from(sourceGenreNames).join(" "), // Search using source genres
      entityType: "artist",
      limit: 100, // Search broadly to find candidates
    });
    if (searchResult.error) return { error: searchResult.error };

    const similarArtists: SimilarArtist[] = [];
    if (searchResult.results) {
      for (const entity of searchResult.results) {
        if (entity.id === artistMbid) continue; // Don't recommend the source artist

        const targetGenresResult = await this.getEntityGenres({
          mbid: entity.id,
          entityType: "artist",
        });
        if (targetGenresResult.genres?.length) {
          const targetGenreNames = new Set(
            targetGenresResult.genres.map((g) => g.name.toLowerCase()),
          );
          let sharedGenreCount = 0;
          let totalGenreCount = sourceGenreNames.size + targetGenreNames.size;

          for (const genre of sourceGenreNames) {
            if (targetGenreNames.has(genre)) {
              sharedGenreCount++;
            }
          }
          // Simple similarity score: (2 * shared) / (total unique)
          const score = totalGenreCount > 0
            ? (2 * sharedGenreCount / totalGenreCount) * 100
            : 0; // Normalize to 0-100

          if (score > 0) {
            similarArtists.push({
              mbid: entity.id,
              name: entity.name || "Unknown Artist",
              score: parseFloat(score.toFixed(2)),
              genres: Array.from(sourceGenreNames).filter((g) =>
                targetGenreNames.has(g)
              ),
            });
          }
        }
      }
    }

    // Sort by score and limit
    similarArtists.sort((a, b) => b.score - a.score);
    return { similarArtists: similarArtists.slice(0, limit) };
  }

  /**
   * getSimilarRecordings(recordingMbid: String, limit: Number): (similarRecordings: List<SimilarRecording>)
   *
   * @requires recordingMbid is valid
   * @effect finds similar recordings (songs/tracks) based on genre/tag overlap. Returns scored list with shared genres.
   */
  async getSimilarRecordings(
    params: { recordingMbid: string; limit?: number },
  ): Promise<{ similarRecordings?: SimilarRecording[]; error?: string }> {
    const { recordingMbid, limit = 10 } = params;
    if (!recordingMbid) return { error: "Recording MBID is required." };

    const sourceGenresResult = await this.getEntityGenres({
      mbid: recordingMbid,
      entityType: "recording",
    });
    if (sourceGenresResult.error || !sourceGenresResult.genres?.length) {
      return { error: sourceGenresResult.error || "Could not fetch source recording genres." };
    }
    const sourceGenreNames = new Set(sourceGenresResult.genres.map((g) => g.name.toLowerCase()));

    const searchResult = await this.searchEntities({
      query: Array.from(sourceGenreNames).join(" "),
      entityType: "recording",
      limit: 100,
    });
    if (searchResult.error) return { error: searchResult.error };

    const similarRecordings: SimilarRecording[] = [];
    if (searchResult.results) {
      for (const entity of searchResult.results) {
        if (entity.id === recordingMbid) continue;

        const targetGenresResult = await this.getEntityGenres({
          mbid: entity.id,
          entityType: "recording",
        });
        if (targetGenresResult.genres?.length) {
          const targetGenreNames = new Set(
            targetGenresResult.genres.map((g) => g.name.toLowerCase()),
          );
          let sharedGenreCount = 0;
          let totalGenreCount = sourceGenreNames.size + targetGenreNames.size;

          for (const genre of sourceGenreNames) {
            if (targetGenreNames.has(genre)) {
              sharedGenreCount++;
            }
          }
          const score = totalGenreCount > 0
            ? (2 * sharedGenreCount / totalGenreCount) * 100
            : 0;

          if (score > 0) {
            similarRecordings.push({
              mbid: entity.id,
              name: entity.title || "Unknown Recording",
              score: parseFloat(score.toFixed(2)),
              genres: Array.from(sourceGenreNames).filter((g) =>
                targetGenreNames.has(g)
              ),
            });
          }
        }
      }
    }
    similarRecordings.sort((a, b) => b.score - a.score);
    return { similarRecordings: similarRecordings.slice(0, limit) };
  }

  /**
   * getSimilarReleaseGroups(releaseGroupMbid: String, limit: Number): (similarReleaseGroups: List<SimilarReleaseGroup>)
   *
   * @requires releaseGroupMbid is valid
   * @effect finds similar release groups (albums) based on genre/tag overlap. Returns scored list with shared genres.
   */
  async getSimilarReleaseGroups(
    params: { releaseGroupMbid: string; limit?: number },
  ): Promise<{ similarReleaseGroups?: SimilarReleaseGroup[]; error?: string }> {
    const { releaseGroupMbid, limit = 10 } = params;
    if (!releaseGroupMbid) return { error: "Release Group MBID is required." };

    const sourceGenresResult = await this.getEntityGenres({
      mbid: releaseGroupMbid,
      entityType: "release-group",
    });
    if (sourceGenresResult.error || !sourceGenresResult.genres?.length) {
      return { error: sourceGenresResult.error || "Could not fetch source release group genres." };
    }
    const sourceGenreNames = new Set(sourceGenresResult.genres.map((g) => g.name.toLowerCase()));

    const searchResult = await this.searchEntities({
      query: Array.from(sourceGenreNames).join(" "),
      entityType: "release-group",
      limit: 100,
    });
    if (searchResult.error) return { error: searchResult.error };

    const similarReleaseGroups: SimilarReleaseGroup[] = [];
    if (searchResult.results) {
      for (const entity of searchResult.results) {
        if (entity.id === releaseGroupMbid) continue;

        const targetGenresResult = await this.getEntityGenres({
          mbid: entity.id,
          entityType: "release-group",
        });
        if (targetGenresResult.genres?.length) {
          const targetGenreNames = new Set(
            targetGenresResult.genres.map((g) => g.name.toLowerCase()),
          );
          let sharedGenreCount = 0;
          let totalGenreCount = sourceGenreNames.size + targetGenreNames.size;

          for (const genre of sourceGenreNames) {
            if (targetGenreNames.has(genre)) {
              sharedGenreCount++;
            }
          }
          const score = totalGenreCount > 0
            ? (2 * sharedGenreCount / totalGenreCount) * 100
            : 0;

          if (score > 0) {
            similarReleaseGroups.push({
              mbid: entity.id,
              name: entity.title || "Unknown Release Group",
              score: parseFloat(score.toFixed(2)),
              genres: Array.from(sourceGenreNames).filter((g) =>
                targetGenreNames.has(g)
              ),
            });
          }
        }
      }
    }
    similarReleaseGroups.sort((a, b) => b.score - a.score);
    return { similarReleaseGroups: similarReleaseGroups.slice(0, limit) };
  }

  /**
   * getRecordingWorks(recordingMbid: String): (works: List<Work>)
   *
   * @requires recordingMbid is valid
   * @effect fetches the musical works (compositions) associated with a recording, including composer and lyricist information.
   */
  async getRecordingWorks(
    params: { recordingMbid: string },
  ): Promise<{ works?: MusicBrainzEntity[]; error?: string }> {
    const { recordingMbid } = params;
    if (!recordingMbid) return { error: "Recording MBID is required." };
    const { data, error } = await this._callApi<MusicBrainzEntity>(
      `recording/${recordingMbid}`,
      { inc: "work-rels" },
    ); // 'work-rels' includes works
    return data ? { works: data.works || [] } : { error };
  }

  /**
   * getCoverArt(releaseMbid: String): (coverArtUrl: String)
   *
   * @requires releaseMbid is valid
   * @effect retrieves the cover art URL for a release from Cover Art Archive (integrated with MusicBrainz).
   */
  async getCoverArt(
    params: { releaseMbid: string },
  ): Promise<{ coverArtUrl?: string; error?: string }> {
    const { releaseMbid } = params;
    if (!releaseMbid) return { error: "Release MBID is required." };

    const cacheKey = `${COVERART_ARCHIVE_API_BASE_URL}${releaseMbid}`;
    const now = new Date();

    // Check cache (TTL for cover art can be longer, e.g., 7 days)
    const cached = await this.entityCache.findOne({ cacheKey });
    if (cached && (now.getTime() - cached.lastFetched.getTime()) <
      7 * 24 * 60 * 60 * 1000) {
      // console.log(`Cache hit for cover art ${releaseMbid}`);
      return { coverArtUrl: cached.metadata.url as string };
    }

    await this._throttle(); // Use the same throttle for consistency
    try {
      const url = `${COVERART_ARCHIVE_API_BASE_URL}${releaseMbid}/front`; // Request front cover
      const response = await fetch(url);

      if (!response.ok) {
        if (response.status === 404) {
          // No cover art available, cache this fact
          await this.entityCache.updateOne(
            { cacheKey },
            {
              $set: {
                mbid: releaseMbid,
                entityType: "cover-art",
                metadata: { url: null }, // Store null to indicate no cover art
                lastFetched: now,
              },
              $setOnInsert: { _id: freshID() },
            },
            { upsert: true },
          );
          return { coverArtUrl: undefined }; // Explicitly return undefined if 404
        }
        const errorText = await response.text();
        console.error(
          `Cover Art Archive error (${response.status}): ${errorText}`,
        );
        return { error: `Cover Art Archive error: ${response.statusText}` };
      }

      // Successful fetch, store the final image URL
      const coverArtUrl = response.url; // The final URL after redirects

      await this.entityCache.updateOne(
        { cacheKey },
        {
          $set: {
            mbid: releaseMbid,
            entityType: "cover-art",
            metadata: { url: coverArtUrl },
            lastFetched: now,
          },
          $setOnInsert: { _id: freshID() },
        },
        { upsert: true },
      );

      return { coverArtUrl };
    } catch (e) {
      console.error(
        `Error fetching cover art for ${releaseMbid}:`,
        e,
      );
      return { error: `Network error or invalid response: ${e.message}` };
    }
  }

  /**
   * clearCache(mbid: String): ()
   *
   * @requires mbid exists in cache
   * @effect removes cached entity data for the specified MBID, forcing fresh API calls on next request.
   */
  async clearCache(
    params: { mbid: string },
  ): Promise<Empty | { error: string }> {
    const { mbid } = params;
    if (!mbid) return { error: "MBID is required to clear cache." };

    try {
      const deleteResult = await this.entityCache.deleteMany({ mbid: mbid });
      if (deleteResult.deletedCount === 0) {
        return { error: `No cached entry found for MBID: ${mbid}` };
      }
      return {};
    } catch (e) {
      console.error(`Error clearing cache for MBID ${mbid}:`, e);
      return { error: `Failed to clear cache: ${e.message}` };
    }
  }
}
```
