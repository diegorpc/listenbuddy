---
timestamp: 'Sat Oct 18 2025 21:58:04 GMT-0400 (Eastern Daylight Time)'
parent: '[[..\20251018_215804.771228b0.md]]'
content_id: fca65e0ea1a7635b77d692ef6f71bca3fc8986873d0b972c7352b1dafeec599e
---

# Backend Concept Development

## Overview

ListenBuddy is a music listening analytics and recommendation platform that combines user scrobble data from ListenBrainz with rich metadata from MusicBrainz to provide personalized listening statistics and AI-enhanced music recommendations. The backend is composed of four primary concepts that work together through synchronizations to deliver this functionality.

## Core Concepts

### 1. User

**Purpose**: Authentication and ListenBrainz account association

Manages user accounts, authentication sessions, and stores ListenBrainz tokens and usernames for API access.

**Key Actions**:

* `createUser(username, password)` - Register new users
* `associateToken(user, scrobbleToken)` - Link ListenBrainz account
* `startSession(username, password)` - Authenticate user
* `endSession(user)` - Logout

### 2. ListenBrainzAPI\[User]

**Purpose**: Retrieve listening statistics and scrobble history

Interfaces with the ListenBrainz API to fetch user listening data, including top artists, albums, tracks, and detailed listen history. Implements caching to reduce API calls. Documentation for the API is at https://listenbrainz.readthedocs.io/en/latest/users/api/

**Key Actions**:

* `getTopArtists(user, timeRange, count)` - Top artists over period
* `getTopReleases(user, timeRange, count)` - Top albums over period
* `getTopReleaseGroups(user, timeRange, count)` - Top album groups over period
* `getTopRecordings(user, timeRange, count)` - Top tracks over period
* `getListenHistory(user, minTs, maxTs, count)` - Individual listens
* `getListeningActivity(user, timeRange)` - Activity timeline
* `validateToken(token)` - Verify ListenBrainz credentials

**Time Ranges**: all\_time, year, half\_year, quarter\_year, month, week

### 3. MusicBrainzAPI

**Purpose**: Retrieve detailed music metadata and relationships

Interfaces with MusicBrainz API to fetch comprehensive information about artists, recordings, releases, and works. Provides relationship data crucial for generating recommendations. Implements rate limiting (1 req/sec) and caching. Documentation for the API is at https://musicbrainz.org/doc/MusicBrainz\_API

**Key Actions**:

* `lookupArtist(mbid, includes)` - Artist details and linked entities
* `lookupRecording(mbid, includes)` - Track/song information
* `lookupRelease(mbid, includes)` - Album details
* `lookupReleaseGroup(mbid, includes)` - Album group information
* `lookupWork(mbid, includes)` - Composition/work details
* `getEntityRelationships(mbid, entityType, relationshipTypes)` - Get relationships between entities
* `getArtistSimilarities(artistMbid)` - Find similar artists via relationships
* `getRecordingWorks(recordingMbid)` - Get composition info for a track
* `getCoverArt(releaseMbid)` - Fetch album artwork URLs
* `searchEntities(query, entityType, limit)` - Search MusicBrainz database

### 4. Recommendation\[Item, MusicBrainzAPI]

**Purpose**: Generate and refine personalized music recommendations

Creates recommendations based on MusicBrainz relationship data and refines them using Gemini LLM. Supports iterative feedback loops where users provide positive/negative feedback to improve future recommendations.

**Key Actions**:

* `generate(sourceItem, amount, source)` - Generate recommendations with reasoning
* `getRecommendations(item, amount)` - Retrieve recommendations for an item
* `provideFeedback(recommendedItem, feedback)` - Store user feedback (positive/negative)
* `clearRecommendations()` - Reset recommendation state

## LLM Integration

### Gemini API Configuration

The system uses environment variables for LLM configuration:

* `GEMINI_API_KEY`: API key for Google Gemini
* `GEMINI_MODEL`: Model identifier (e.g., "gemini-2.5-flash")

### LLM Recommendations

Input to LLM:

* Source item (artist/album/track) metadata
* MusicBrainz relationships (collaborations, influences, similar artists)
* Musical attributes (genre, style, era)
* User feedback history (what they liked/disliked before)

Output from LLM:

* Natural language explanation for each recommendation
* Confidence scores based on relationship strength
* Personalized insights based on user's listening patterns

### Prompt Structure Idea

```
You are a music recommendation assistant. Generate recommendations based on:

SOURCE ITEM: {artist/album/track name and details}

MUSICBRAINZ RELATIONSHIPS:
- Collaborated with: [list]
- Similar artists: [list]
- Genre/style tags: [list]
- Associated works: [list]

USER FEEDBACK HISTORY:
Positive: [items user liked with reasoning]
Negative: [items user disliked with reasoning]

Generate {N} recommendations with:
1. Item name and MBID
2. Natural language reasoning (2-3 sentences)
3. Confidence score (0-1)

Prioritize items that match positive feedback patterns and avoid negative patterns.
```

## Backend Implementation Notes

### Caching Strategy

* **ListenBrainzAPI**: Cache statistics with TTL (e.g., 1 hour for short ranges, 24 hours for all\_time)
* **MusicBrainzAPI**: Cache entity lookups and relationships (longer TTL, data rarely changes)
* **Recommendation**: Cache generated recommendations until feedback is provided

### Rate Limiting

* **ListenBrainzAPI**: Generally permissive, but implement exponential backoff
* **MusicBrainzAPI**: Strict 1 request/second limit, queue requests
* **Gemini API**: Monitor quota usage, implement retry logic

### Error Handling

* Invalid tokens: Prompt user to re-authenticate
* API timeouts: Serve cached data with staleness indicator
* Missing MBIDs: Gracefully degrade (show item without relationships)
* LLM failures: Fall back to relationship-based recommendations without reasoning

### Database Schema Considerations

We will be using a MongoDB database for our backend. The following are some proposed collections:

**Users Collection**:

* id, username, password (hashed), scrobbleToken, listenBrainzName, created\_at

**Statistics Cache Collection**:

* user\_id, stat\_type, time\_range, data (JSON), last\_updated

**Recommendations Collection**:

* id, user\_id, source\_item\_mbid, recommended\_item\_mbid, reasoning, confidence, created\_at

**Feedback Collection**:

* id, user\_id, recommendation\_id, is\_positive, created\_at
