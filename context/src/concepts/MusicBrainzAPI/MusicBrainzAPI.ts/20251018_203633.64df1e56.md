---
timestamp: 'Sat Oct 18 2025 20:36:33 GMT-0400 (Eastern Daylight Time)'
content_id: 64df1e5655898606d31a76627b690f0650d2011026fe56354d39f4453061338e
---

# file: src/concepts/MusicBrainzAPI/MusicBrainzAPI.ts

```typescript
import { Collection, Db } from "npm:mongodb";
import { ID } from "@utils/types.ts";
import { freshID } from "@utils/database.ts";

// Declare collection prefix, use concept name
const PREFIX = "MusicBrainzAPI" + ".";

// MusicBrainz API Configuration
const MUSICBRAINZ_API_BASE_URL = "https://musicbrainz.org/ws/2/";
const COVER_ART_API_BASE_URL = "https://coverartarchive.org/release/";
const RATE_LIMIT_DELAY_MS = 1100; // ~1 request per second + buffer
const USER_AGENT = "ListenBuddy/1.0.0 (diegorpc@mit.edu)";

// Generic types of this concept
type EntityMbid = ID;
type RelationshipType = string; // e.g., "artist-rels", "recording-rels"
type EntityType =
  | "artist"
  | "recording"
  | "release"
  | "release-group"
  | "work";

// Detailed MusicBrainz API response types based on actual responses
interface MBLifeSpan {
  begin?: string | null;
  end?: string | null;
  ended: boolean;
}

interface MBArea {
  id: string;
  type?: string | null;
  "type-id"?: string | null;
  name: string;
  "sort-name": string;
  disambiguation?: string;
  "iso-3166-1-codes"?: string[];
  "life-span"?: MBLifeSpan;
}

interface MBArtist {
  id: string;
  name: string;
  "sort-name": string;
  disambiguation?: string;
  type?: string;
  "type-id"?: string;
  "gender"?: string | null;
  "gender-id"?: string | null;
  country?: string;
  area?: MBArea;
  "begin-area"?: MBArea;
  "end-area"?: MBArea | null;
  "life-span"?: MBLifeSpan;
  ipis?: string[];
  isnis?: string[];
  aliases?: MBAlias[];
  tags?: MBTag[];
  relations?: MBRelation[];
  releases?: MBRelease[];
}

interface MBAlias {
  name: string;
  "sort-name": string;
  type?: string;
  "type-id"?: string;
  locale?: string | null;
  primary?: boolean | null;
  "begin-date"?: string | null;
  "end-date"?: string | null;
}

interface MBTag {
  name: string;
  count: number;
}

interface MBArtistCredit {
  name: string;
  artist?: MBArtist;
  joinphrase?: string;
}

interface MBWork {
  id: string;
  title: string;
  type?: string;
  "type-id"?: string;
  disambiguation?: string;
  language?: string;
  languages?: string[];
  iswcs?: string[];
  attributes?: MBWorkAttribute[];
  relations?: MBRelation[];
}

interface MBWorkAttribute {
  type: string;
  "type-id": string;
  value: string;
}

interface MBRecording {
  id: string;
  title: string;
  length?: number;
  disambiguation?: string;
  video?: boolean;
  "artist-credit"?: MBArtistCredit[];
  releases?: MBRelease[];
  isrcs?: string[];
  tags?: MBTag[];
  relations?: MBRelation[];
}

interface MBRelease {
  id: string;
  title: string;
  status?: string;
  "status-id"?: string;
  date?: string;
  country?: string;
  disambiguation?: string;
  barcode?: string | null;
  "artist-credit"?: MBArtistCredit[];
  "release-group"?: MBReleaseGroup;
  media?: MBMedia[];
  "label-info"?: MBLabelInfo[];
  "cover-art-archive"?: MBCoverArtArchive;
  relations?: MBRelation[];
}

interface MBMedia {
  title?: string;
  position: number;
  format?: string;
  "format-id"?: string;
  "track-count": number;
  "track-offset"?: number;
  tracks?: MBTrack[];
}

interface MBTrack {
  id: string;
  position: number;
  number: string;
  title: string;
  length?: number;
  recording?: MBRecording;
  "artist-credit"?: MBArtistCredit[];
}

interface MBReleaseGroup {
  id: string;
  title: string;
  "primary-type"?: string;
  "primary-type-id"?: string;
  "secondary-types"?: string[];
  "secondary-type-ids"?: string[];
  "first-release-date"?: string;
  disambiguation?: string;
  "artist-credit"?: MBArtistCredit[];
  releases?: MBRelease[];
  tags?: MBTag[];
  relations?: MBRelation[];
}

interface MBLabelInfo {
  "catalog-number"?: string;
  label?: MBLabel;
}

interface MBLabel {
  id: string;
  name: string;
  "sort-name": string;
  disambiguation?: string;
  type?: string;
  "type-id"?: string;
}

interface MBCoverArtArchive {
  artwork: boolean;
  count: number;
  front: boolean;
  back: boolean;
  darkened: boolean;
}

interface MBRelation {
  type: string;
  "type-id"?: string;
  "target-type": string;
  "target-credit"?: string;
  "source-credit"?: string;
  direction?: string;
  begin?: string;
  end?: string;
  ended?: boolean;
  attributes?: string[];
  "attribute-values"?: Record<string, string>;
  "attribute-ids"?: Record<string, string>;
  artist?: MBArtist;
  work?: MBWork;
  recording?: MBRecording;
  release?: MBRelease;
  "release-group"?: MBReleaseGroup;
  url?: MBUrl;
  genre?: MBGenre;
}

interface MBUrl {
  id: string;
  resource: string;
}

interface MBGenre {
  id: string;
  name: string;
  disambiguation?: string;
}

interface MBSearchResult {
  score: number;
  id: string;
  name?: string;
  title?: string;
  "sort-name"?: string;
  type?: string;
  "type-id"?: string;
  disambiguation?: string;
  country?: string;
  area?: MBArea;
  "begin-area"?: MBArea;
  "life-span"?: MBLifeSpan;
  isnis?: string[];
  aliases?: MBAlias[];
  tags?: MBTag[];
  "artist-credit"?: MBArtistCredit[];
}

/**
 * A set of EntityCache with:
 *   an mbid of type String (MusicBrainz ID)
 *   an entityType of type String ("artist", "recording", "release", "release-group", "work")
 *   a metadata of type JSON
 *   a lastFetched of type Timestamp
 */
interface EntityCache {
  _id: ID; // Combined MBID and entityType for unique ID
  mbid: EntityMbid;
  entityType: EntityType;
  metadata: any;
  lastFetched: Date;
}

/**
 * A set of RelationshipCache with:
 *   an mbid of type String
 *   a relationshipType of type String ("artist-rels", "recording-rels", "work-rels", etc.)
 *   a relationships of type List<JSON>
 *   a lastFetched of type Timestamp
 */
interface RelationshipCache {
  _id: ID; // Combined MBID and relationshipType for unique ID
  mbid: EntityMbid;
  relationshipType: RelationshipType;
  relationships: any[];
  lastFetched: Date;
}

// In-memory rate limit state for simplicity, can be made persistent if needed for distributed instances
interface RateLimitState {
  lastRequestTime: Date;
}

export default class MusicBrainzAPIConcept {
  private entityCache: Collection<EntityCache>;
  private relationshipCache: Collection<RelationshipCache>;
  private rateLimitState: RateLimitState;

  // TTL for caches (can be adjusted)
  private static readonly ENTITY_CACHE_TTL_MS = 24 * 60 * 60 * 1000; // 24 hours
  private static readonly RELATIONSHIP_CACHE_TTL_MS = 7 * 24 * 60 * 60 * 1000; // 7 days

  constructor(private readonly db: Db) {
    this.entityCache = this.db.collection(PREFIX + "entityCache");
    this.relationshipCache = this.db.collection(PREFIX + "relationshipCache");
    this.rateLimitState = { lastRequestTime: new Date(0) }; // Initialize to a past date
  }

  /**
   * Internal helper to enforce MusicBrainz API rate limit (1 request/second).
   * Blocks until enough time has passed since the last request.
   */
  private async _waitForRateLimit(): Promise<void> {
    const now = new Date();
    const timeSinceLastRequest = now.getTime() -
      this.rateLimitState.lastRequestTime.getTime();

    if (timeSinceLastRequest < RATE_LIMIT_DELAY_MS) {
      const delay = RATE_LIMIT_DELAY_MS - timeSinceLastRequest;
      // console.warn(`MusicBrainzAPI: Rate limit hit. Waiting for ${delay}ms.`);
      await new Promise((resolve) => setTimeout(resolve, delay));
    }
    this.rateLimitState.lastRequestTime = new Date(); // Update last request time
  }

  /**
   * Internal helper to make a request to the MusicBrainz API, handling caching and rate limiting.
   * @param path The API endpoint path (e.g., "artist/{mbid}").
   * @param params URLSearchParams for query parameters.
   * @param cacheCollection The MongoDB collection to use for caching (entityCache or relationshipCache).
   * @param cacheKey The unique key to use for identifying this cached item (e.g., MBID or MBID+type).
   * @param cacheType A string to differentiate cache entries (e.g., "artist", "recording", "artist-rels").
   * @param ttlMs Time-to-live for the cache entry in milliseconds.
   * @returns The parsed JSON response or an error object.
   */
  private async _fetchAndCache<T>(
    entityType: EntityType | RelationshipType | "search" | "browse",
    mbid: EntityMbid | string | null, // Can be null for search/browse
    requestUrl: URL,
    cacheCollection: Collection<any>,
    ttlMs: number,
  ): Promise<T | { error: string }> {
    // Use full URL as cache key to include query parameters (like inc=releases)
    // This ensures different includes don't share the same cache entry
    const cacheIdentifier = requestUrl.toString() as ID;

    // 1. Check cache first
    const cachedData = await cacheCollection.findOne({ _id: cacheIdentifier });

    if (cachedData) {
      if (
        new Date().getTime() - cachedData.lastFetched.getTime() <
          ttlMs
      ) {
        // console.log(`MusicBrainzAPI: Cache hit for ${cacheIdentifier}`);
        return cachedData.metadata || cachedData.relationships;
      } else {
        // console.log(`MusicBrainzAPI: Cache expired for ${cacheIdentifier}`);
        // Optionally delete expired cache here to keep it clean, but usually just overwrite.
      }
    }

    // 2. Enforce rate limit
    await this._waitForRateLimit();

    // 3. Make the API call
    try {
      const response = await fetch(requestUrl.toString(), {
        headers: { "User-Agent": USER_AGENT },
      });

      if (!response.ok) {
        if (response.status === 404 || response.status === 400) {
          return { error: `Entity not found: ${mbid}` };
        }
        throw new Error(
          `MusicBrainz API error: ${response.status} ${response.statusText}`,
        );
      }

      const data = await response.json();

      // 4. Cache the result
      const newCacheEntry: any = {
        _id: cacheIdentifier,
        lastFetched: new Date(),
      };

      if (
        entityType === "artist" ||
        entityType === "recording" ||
        entityType === "release" ||
        entityType === "release-group" ||
        entityType === "work"
      ) {
        Object.assign(newCacheEntry, {
          mbid: mbid,
          entityType: entityType,
          metadata: data,
        });
      } else { // This handles relationship types, search, and browse
        Object.assign(newCacheEntry, {
          mbid: mbid, // Can be null for search/browse but still useful
          relationshipType: entityType, // Reusing field for generic type
          metadata: data, // Store full response for search/browse
          relationships: data.relations || data.artists || data.recordings ||
            data.releases || data["release-groups"] || data.works, // Extract specific lists if available
        });
      }

      await cacheCollection.updateOne(
        { _id: cacheIdentifier },
        { $set: newCacheEntry },
        { upsert: true },
      );
      // console.log(`MusicBrainzAPI: Cached ${cacheIdentifier}`);

      // Return the actual data part for different request types
      if (entityType === "search" || entityType === "browse") {
        return newCacheEntry.metadata as T;
      }
      return newCacheEntry.metadata || newCacheEntry.relationships as T;
    } catch (error: any) {
      console.error(
        `MusicBrainzAPI: Error fetching ${requestUrl.toString()}:`,
        error,
      );
      return {
        error: `Failed to fetch from MusicBrainz API: ${error.message}`,
      };
    }
  }

  /**
   * lookupArtist(mbid: String, includes: List<String>): (artist: JSON)
   *
   * requires: mbid is valid MusicBrainz artist ID, includes contains valid subquery types
   * effect: fetches detailed artist information from MusicBrainz API including optional subqueries (recordings, releases, release-groups, works, artist-rels, etc.).
   * Returns artist name, aliases, area, type, and requested linked entities.
   */
  async lookupArtist(
    { mbid, includes = [] }: { mbid: EntityMbid; includes?: string[] },
  ): Promise<{ artist?: MBArtist; error?: string }> {
    if (!mbid) return { error: "MBID is required." };

    const url = new URL(`${MUSICBRAINZ_API_BASE_URL}artist/${mbid}`);
    url.searchParams.set("fmt", "json");
    if (includes.length > 0) {
      url.searchParams.set("inc", includes.join("+"));
    }

    const result = await this._fetchAndCache<any>(
      "artist",
      mbid,
      url,
      this.entityCache,
      MusicBrainzAPIConcept.ENTITY_CACHE_TTL_MS,
    );
    if ("error" in result) return result;
    // MusicBrainz API returns entity data directly at the root
    return { artist: result };
  }

  /**
   * lookupRecording(mbid: String, includes: List<String>): (recording: JSON)
   *
   * requires: mbid is valid MusicBrainz recording ID, includes contains valid subquery types
   * effect: fetches recording (track/song) information including title, length, artists, and optionally releases, ISRCs, work relationships, and artist relationships.
   */
  async lookupRecording(
    { mbid, includes = [] }: { mbid: EntityMbid; includes?: string[] },
  ): Promise<{ recording?: MBRecording; error?: string }> {
    if (!mbid) return { error: "MBID is required." };

    const url = new URL(`${MUSICBRAINZ_API_BASE_URL}recording/${mbid}`);
    url.searchParams.set("fmt", "json");
    if (includes.length > 0) {
      url.searchParams.set("inc", includes.join("+"));
    }

    const result = await this._fetchAndCache<any>(
      "recording",
      mbid,
      url,
      this.entityCache,
      MusicBrainzAPIConcept.ENTITY_CACHE_TTL_MS,
    );
    if ("error" in result) return result;
    // MusicBrainz API returns entity data directly at the root
    return { recording: result };
  }

  /**
   * lookupRelease(mbid: String, includes: List<String>): (release: JSON)
   *
   * requires: mbid is valid MusicBrainz release ID, includes contains valid subquery types
   * effect: fetches release (album) information including title, date, status, artists, labels, and optionally recordings, release-group, cover art, and relationships.
   */
  async lookupRelease(
    { mbid, includes = [] }: { mbid: EntityMbid; includes?: string[] },
  ): Promise<{ release?: MBRelease; error?: string }> {
    if (!mbid) return { error: "MBID is required." };

    const url = new URL(`${MUSICBRAINZ_API_BASE_URL}release/${mbid}`);
    url.searchParams.set("fmt", "json");
    if (includes.length > 0) {
      url.searchParams.set("inc", includes.join("+"));
    }

    const result = await this._fetchAndCache<any>(
      "release",
      mbid,
      url,
      this.entityCache,
      MusicBrainzAPIConcept.ENTITY_CACHE_TTL_MS,
    );
    if ("error" in result) return result;
    // MusicBrainz API returns entity data directly at the root
    return { release: result };
  }

  /**
   * lookupReleaseGroup(mbid: String, includes: List<String>): (releaseGroup: JSON)
   *
   * requires: mbid is valid MusicBrainz release-group ID, includes contains valid subquery types
   * effect: fetches release group information including title, type, artists, and optionally individual releases and relationships.
   */
  async lookupReleaseGroup(
    { mbid, includes = [] }: { mbid: EntityMbid; includes?: string[] },
  ): Promise<{ releaseGroup?: MBReleaseGroup; error?: string }> {
    if (!mbid) return { error: "MBID is required." };

    const url = new URL(`${MUSICBRAINZ_API_BASE_URL}release-group/${mbid}`);
    url.searchParams.set("fmt", "json");
    if (includes.length > 0) {
      url.searchParams.set("inc", includes.join("+"));
    }

    const result = await this._fetchAndCache<any>(
      "release-group",
      mbid,
      url,
      this.entityCache,
      MusicBrainzAPIConcept.ENTITY_CACHE_TTL_MS,
    );
    if ("error" in result) return result;
    // MusicBrainz API returns entity data directly at the root
    return { releaseGroup: result };
  }

  /**
   * lookupWork(mbid: String, includes: List<String>): (work: JSON)
   *
   * requires: mbid is valid MusicBrainz work ID, includes contains valid subquery types
   * effect: fetches work (composition) information including title, type, and relationships to artists (composers, lyricists), recordings, and other works.
   */
  async lookupWork(
    { mbid, includes = [] }: { mbid: EntityMbid; includes?: string[] },
  ): Promise<{ work?: MBWork; error?: string }> {
    if (!mbid) return { error: "MBID is required." };

    const url = new URL(`${MUSICBRAINZ_API_BASE_URL}work/${mbid}`);
    url.searchParams.set("fmt", "json");
    if (includes.length > 0) {
      url.searchParams.set("inc", includes.join("+"));
    }

    const result = await this._fetchAndCache<any>(
      "work",
      mbid,
      url,
      this.entityCache,
      MusicBrainzAPIConcept.ENTITY_CACHE_TTL_MS,
    );
    if ("error" in result) return result;
    // MusicBrainz API returns entity data directly at the root
    return { work: result };
  }

  /**
   * getEntityRelationships(mbid: String, entityType: String, relationshipTypes: List<String>): (relationships: List<Relationship>)
   *
   * requires: mbid is valid, entityType is one of the supported entity types, relationshipTypes contains valid relationship types
   * effect: fetches all relationships of specified types for an entity. Returns list of relationships with target entities, relationship type, and attributes.
   * Used to find similar artists, cover versions, samples, etc.
   */
  async getEntityRelationships(
    { mbid, entityType, relationshipTypes = [] }: {
      mbid: EntityMbid;
      entityType: EntityType;
      relationshipTypes?: string[];
    },
  ): Promise<{ relationships?: MBRelation[]; error?: string }> {
    if (!mbid) return { error: "MBID is required." };
    if (
      !["artist", "recording", "release", "release-group", "work"].includes(
        entityType,
      )
    ) {
      return { error: "Invalid entityType." };
    }
    // relationshipTypes are implicitly validated by what the MB API accepts in 'inc'

    const url = new URL(`${MUSICBRAINZ_API_BASE_URL}${entityType}/${mbid}`);
    url.searchParams.set("fmt", "json");
    if (relationshipTypes.length > 0) {
      url.searchParams.set("inc", relationshipTypes.join("+"));
    } else {
      // If no specific relationship types are requested, get common relationship types
      url.searchParams.set(
        "inc",
        "url-rels+artist-rels+recording-rels+work-rels+label-rels",
      );
    }

    // The _fetchAndCache will handle parsing the 'relations' array from the result
    const result = await this._fetchAndCache<any>(
      entityType, // Use entityType for caching since this is still entity data with relations
      mbid,
      url,
      this.entityCache, // Use entityCache since this is entity data
      MusicBrainzAPIConcept.ENTITY_CACHE_TTL_MS,
    );

    if ("error" in result) return result;
    // MusicBrainz API returns relationships under the 'relations' key in the entity object
    return { relationships: result.relations || [] };
  }

  /**
   * searchEntities(query: String, entityType: String, limit: Number): (results: List<JSON>)
   *
   * requires: query is non-empty, entityType is valid ("artist", "recording", "release", etc.), limit is positive
   * effect: searches MusicBrainz database for entities matching the query string. Returns ranked list of matching entities with scores.
   */
  async searchEntities(
    { query, entityType, limit = 25 }: {
      query: string;
      entityType: EntityType;
      limit?: number;
    },
  ): Promise<{ results?: MBSearchResult[]; error?: string }> {
    if (!query || query.trim() === "") {
      return { error: "Query cannot be empty." };
    }
    if (
      !["artist", "recording", "release", "release-group", "work"].includes(
        entityType,
      )
    ) {
      return { error: "Invalid entityType." };
    }
    if (limit <= 0) return { error: "Limit must be positive." };

    const url = new URL(`${MUSICBRAINZ_API_BASE_URL}${entityType}`);
    url.searchParams.set("fmt", "json");
    url.searchParams.set("query", query);
    url.searchParams.set("limit", limit.toString());

    const result = await this._fetchAndCache<any>(
      "search",
      null, // No specific MBID for search
      url,
      this.entityCache, // Using entityCache for search results as well
      MusicBrainzAPIConcept.ENTITY_CACHE_TTL_MS,
    );
    if ("error" in result) return result;

    // MusicBrainz search results are typically under an array key matching the entity type (e.g., 'artists', 'recordings')
    // Handle special case for release-group which becomes release-groups in the API response
    const entityKey = entityType === "release-group"
      ? "release-groups"
      : `${entityType}s`;
    return { results: result[entityKey] || [] };
  }

  /**
   * browseByEntity(entityType: String, linkedEntity: String, linkedMbid: String, limit: Number, offset: Number): (results: List<JSON>)
   *
   * requires: entityType and linkedEntity are valid types, linkedMbid exists, limit and offset are non-negative
   * effect: browses entities linked to a specific entity (e.g., all releases by an artist, all recordings of a work). Supports pagination.
   */
  async browseByEntity(
    { entityType, linkedEntity, linkedMbid, limit = 25, offset = 0 }: {
      entityType: EntityType;
      linkedEntity: EntityType;
      linkedMbid: EntityMbid;
      limit?: number;
      offset?: number;
    },
  ): Promise<
    {
      results?:
        (MBArtist | MBRecording | MBRelease | MBReleaseGroup | MBWork)[];
      error?: string;
    }
  > {
    if (!linkedMbid) return { error: "linkedMbid is required." };
    if (
      !["artist", "recording", "release", "release-group", "work"].includes(
        entityType,
      )
    ) {
      return { error: "Invalid entityType." };
    }
    if (
      !["artist", "recording", "release", "release-group", "work"].includes(
        linkedEntity,
      )
    ) {
      return { error: "Invalid linkedEntity type." };
    }
    if (limit < 0 || offset < 0) {
      return { error: "Limit and offset must be non-negative." };
    }

    const url = new URL(`${MUSICBRAINZ_API_BASE_URL}${entityType}`);
    url.searchParams.set("fmt", "json");
    url.searchParams.set(linkedEntity, linkedMbid); // e.g., ?artist={mbid}
    url.searchParams.set("limit", limit.toString());
    url.searchParams.set("offset", offset.toString());

    const result = await this._fetchAndCache<any>(
      "browse",
      linkedMbid, // Use linkedMbid as a context for caching
      url,
      this.entityCache,
      MusicBrainzAPIConcept.ENTITY_CACHE_TTL_MS,
    );
    if ("error" in result) return result;

    // Handle special case for release-group which becomes release-groups in the API response
    const entityKey = entityType === "release-group"
      ? "release-groups"
      : `${entityType}s`;
    return { results: result[entityKey] || [] };
  }

  /**
   * getArtistSimilarities(artistMbid: String): (similarArtists: List<Artist>)
   *
   * requires: artistMbid is valid
   * effect: fetches artists with relationships to the given artist (collaborations, member-of, similar-to)
   * and returns them as potential similar artists for recommendations.
   */
  async getArtistSimilarities(
    { artistMbid }: { artistMbid: EntityMbid },
  ): Promise<{ similarArtists?: any[]; error?: string }> {
    if (!artistMbid) return { error: "artistMbid is required." };

    // Fetch artist with relationships (including genre relationships)
    const artistResult = await this.lookupArtist({
      mbid: artistMbid,
      includes: ["artist-rels", "genre-rels"],
    });

    if ("error" in artistResult) return artistResult;

    const artist = artistResult.artist;
    if (!artist) return { error: "Artist data not found." };
    const similarArtists: any[] = [];

    // Filter relationships to find 'similar-to', 'collaborated-with', 'member-of', etc.
    if (artist.relations) {
      for (const rel of artist.relations) {
        // Example: filter for specific relationship types that imply similarity or connection
        if (
          ["member of", "collaboration", "similar to"].includes(
            rel.type.toLowerCase(),
          ) && rel["target-type"] === "artist" && rel.artist
        ) {
          similarArtists.push({
            mbid: rel.artist.id,
            name: rel.artist.name,
            type: rel.type,
            direction: rel.direction,
          });
        }
      }
    }

    return { similarArtists: similarArtists };
  }

  /**
   * getRecordingWorks(recordingMbid: String): (works: List<Work>)
   *
   * requires: recordingMbid is valid
   * effect: fetches the musical works (compositions) associated with a recording,
   * including composer and lyricist information.
   */
  async getRecordingWorks(
    { recordingMbid }: { recordingMbid: EntityMbid },
  ): Promise<{ works?: any[]; error?: string }> {
    if (!recordingMbid) return { error: "recordingMbid is required." };

    const recordingResult = await this.lookupRecording({
      mbid: recordingMbid,
      includes: ["work-rels"],
    });

    if ("error" in recordingResult) return recordingResult;

    const recording = recordingResult.recording;
    if (!recording) return { error: "Recording data not found." };
    const associatedWorks: any[] = [];

    if (recording.relations) {
      for (const rel of recording.relations) {
        if (
          rel.type === "performance" && rel["target-type"] === "work" &&
          rel.work
        ) {
          // Fetch full work details with artist relationships
          const workResult = await this.lookupWork({
            mbid: rel.work.id as ID,
            includes: ["artist-rels"],
          });

          if ("error" in workResult) continue; // Skip works that fail to fetch

          const workData = workResult.work;
          if (!workData) continue;
          const artists: any[] = [];

          // Extract composer and lyricist relationships from work
          if (workData.relations) {
            for (const wrel of workData.relations) {
              if (
                wrel["target-type"] === "artist" &&
                ["composer", "lyricist"].includes(wrel.type) &&
                wrel.artist
              ) {
                artists.push({
                  mbid: wrel.artist.id,
                  name: wrel.artist.name,
                  type: wrel.type,
                });
              }
            }
          }

          const work = {
            mbid: workData.id,
            title: workData.title,
            type: workData.type,
            artists: artists,
          };
          associatedWorks.push(work);
        }
      }
    }

    return { works: associatedWorks };
  }

  /**
   * getCoverArt(releaseMbid: String): (coverArtUrl: String)
   *
   * requires: releaseMbid is valid
   * effect: retrieves the cover art URL for a release from Cover Art Archive (integrated with MusicBrainz).
   */
  async getCoverArt(
    { releaseMbid }: { releaseMbid: EntityMbid },
  ): Promise<{ coverArtUrl?: string; error?: string }> {
    if (!releaseMbid) return { error: "releaseMbid is required." };

    const url = new URL(`${COVER_ART_API_BASE_URL}${releaseMbid}/front`);
    // Cover Art Archive doesn't use the same JSON format or caching mechanism as MB API directly,
    // so we'll treat it as a direct fetch for the URL.
    // We could still cache the URL in entityCache if we wanted to avoid repeated HTTP HEAD requests.

    // A HEAD request is often sufficient to check for image existence without downloading
    await this._waitForRateLimit(); // Still apply rate limiting as it's an external API call
    try {
      const response = await fetch(url.toString(), { method: "HEAD" });

      if (response.ok) {
        // If a "front" image exists, return its URL.
        // The actual image is at the same URL if GET is used.
        return { coverArtUrl: url.toString() };
      } else if (response.status === 404) {
        return { error: "Cover art not found for this release." };
      } else {
        throw new Error(
          `Cover Art Archive error: ${response.status} ${response.statusText}`,
        );
      }
    } catch (error: any) {
      console.error(
        `MusicBrainzAPI: Error fetching cover art ${url.toString()}:`,
        error,
      );
      return { error: `Failed to fetch cover art: ${error.message}` };
    }
  }

  /**
   * clearCache(mbid: String): ()
   *
   * requires: mbid exists in cache
   * effect: removes cached entity and relationship data for the specified MBID,
   * forcing fresh API calls on next request.
   */
  async clearCache(
    { mbid }: { mbid: EntityMbid },
  ): Promise<{ error?: string }> {
    if (!mbid) return { error: "MBID is required." };

    // Delete entries from entity cache where _id contains the mbid
    // Since _id is now the full URL, we need to match URLs containing this mbid
    await this.entityCache.deleteMany({ _id: { $regex: mbid } as any });
    // Delete entries from relationship cache where _id contains the mbid
    await this.relationshipCache.deleteMany({ _id: { $regex: mbid } as any });

    return {};
  }
}

```
